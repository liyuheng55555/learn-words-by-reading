// --- Vocabulary source list (unique, in requested order) ---
// This will be dynamically populated based on uploaded article
let VOCABS = [];
const VARIANT_TO_ORIGINAL = new Map();
const ORIGINAL_TO_VARIANT = new Map();
const TERM_CONTEXTS = new Map();
let CURRENT_ARTICLE_MARKDOWN = '';

const listEl = document.getElementById('list');
const filterEl = document.getElementById('filter');

// Mode elements
const editModeBtn = document.getElementById('edit-mode-btn');
const viewModeBtn = document.getElementById('view-mode-btn');
const editSection = document.getElementById('edit-section');
const viewSection = document.getElementById('view-section');
const articleEditor = document.getElementById('article-editor');
const saveArticleBtn = document.getElementById('save-article-btn');
const editorStatus = document.getElementById('editor-status');
const articleContent = document.getElementById('article-content');
const generatorWordsEl = document.getElementById('generator-words');
const generateArticleBtn = document.getElementById('generate-article-btn');
const generatorStatusEl = document.getElementById('generator-status');
const startGradeBtn = document.getElementById('start-grade');
const syncServerBtn = document.getElementById('sync-server');
const syncStatusEl = document.getElementById('sync-status');
const serverScoresEl = document.getElementById('server-scores');
const scoreApiUrlInput = document.getElementById('score-api-url');
const apiUrlInput = document.getElementById('api-url');
const apiKeyInput = document.getElementById('api-key');
const aiModelInput = document.getElementById('ai-model');
const practicedCountInput = document.getElementById('practiced-count');
const totalCountInput = document.getElementById('total-count');
const masteryThresholdInput = document.getElementById('mastery-threshold');
const autoFillWordsBtn = document.getElementById('auto-fill-words');

if (syncServerBtn && !syncServerBtn.dataset.originalText) {
  syncServerBtn.dataset.originalText = syncServerBtn.textContent;
}

renderServerScores([]);
setSyncStatus('', 'info');

const DEFAULT_ARTICLE_WORD_GOAL = 220;
const DEFAULT_ARTICLE_PARAGRAPH_COUNT = 3;
const SIMILARITY_THRESHOLD_STRICT = 0.85;
const SIMILARITY_THRESHOLD_PARTIAL = 0.6;

let LAST_GRADING_RESULTS = {};

// Build items
function makeId(term){
  return 'term-' + term.toLowerCase().replace(/[^a-z0-9]+/g,'-');
}

function registerVariantMapping(original, used) {
  const originalTrim = typeof original === 'string' ? original.trim() : '';
  if (!originalTrim) return;
  const usedTrim = typeof used === 'string' && used.trim() ? used.trim() : originalTrim;
  VARIANT_TO_ORIGINAL.set(usedTrim.toLowerCase(), originalTrim);
  VARIANT_TO_ORIGINAL.set(originalTrim.toLowerCase(), originalTrim);
  ORIGINAL_TO_VARIANT.set(originalTrim, usedTrim);
}

function resetVariantMappings(pairs = []) {
  VARIANT_TO_ORIGINAL.clear();
  ORIGINAL_TO_VARIANT.clear();
  if (!Array.isArray(pairs)) return;
  for (const entry of pairs) {
    if (!entry || typeof entry !== 'object') continue;
    registerVariantMapping(entry.original, entry.used);
  }
}

function getOriginalFromVariant(variant) {
  if (!variant) return null;
  const key = variant.trim().toLowerCase();
  if (VARIANT_TO_ORIGINAL.has(key)) return VARIANT_TO_ORIGINAL.get(key);
  const fallback = VOCABS.find(term => term.toLowerCase() === key);
  return fallback || null;
}

function getVariantForOriginal(original) {
  if (!original) return null;
  const originalTrim = original.trim();
  return ORIGINAL_TO_VARIANT.get(originalTrim) || originalTrim;
}

function jumpTo(term){
  const variant = getVariantForOriginal(term) || term;
  const anchorId = 't-' + variant.toLowerCase().replace(/[^a-z0-9]+/g,'-');
  const byId = document.getElementById(anchorId);
  if (byId) { byId.scrollIntoView({behavior:'smooth', block:'center'}); highlight(byId); return; }
  const strongs = document.querySelectorAll('#article-content strong');
  const targetLower = variant.toLowerCase();
  for (const s of strongs){
    const text = s.textContent.trim().toLowerCase();
    if (text === targetLower || text.includes(targetLower)) { s.scrollIntoView({behavior:'smooth', block:'center'}); highlight(s); return; }
  }
  alert('Âú®ÊñáÁ´†‰∏≠Êú™ÊâæÂà∞ËØ•ËØçÔºö' + term);
}

function highlight(el){
  el.style.outline = '2px solid var(--accent-2)';
  el.style.boxShadow = '0 0 0 4px rgba(137,220,235,.25)';
  setTimeout(()=>{ el.style.outline = ''; el.style.boxShadow=''; }, 1500);
}

function parseGeneratorWords(raw){
  if (!raw) return [];
  const parts = raw.split(/[\n,Ôºå„ÄÅÔºõ;]+/);
  const seen = new Set();
  const words = [];
  for (const part of parts){
    const word = part.trim();
    if (word && !seen.has(word)){
      seen.add(word);
      words.push(word);
    }
  }
  return words;
}

function escapeRegExp(str){
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function extractMessageText(message){
  if (!message) return '';
  const { content, text, tool_calls: toolCalls } = message;

  const normalizePart = (part) => {
    if (!part) return '';
    if (typeof part === 'string') return part;
    if (typeof part === 'number' || typeof part === 'boolean') return String(part);
    if (typeof part === 'object') {
      if (typeof part.text === 'string') return part.text;
      if (Array.isArray(part.text)) return part.text.map(normalizePart).join('');
      if (part.type === 'text' && typeof part.value === 'string') return part.value;
      if (part.type === 'text' && typeof part.data === 'string') return part.data;
      if (part.type === 'tool_call' && part.function?.arguments) {
        return '';
      }
      return '';
    }
    return '';
  };

  let chunks = [];

  if (typeof content === 'string') {
    chunks.push(content);
  } else if (Array.isArray(content)) {
    chunks.push(content.map(normalizePart).join(''));
  } else if (content && typeof content === 'object') {
    if (typeof content.text === 'string') {
      chunks.push(content.text);
    } else if (Array.isArray(content.text)) {
      chunks.push(content.text.map(normalizePart).join(''));
    }
  }

  if (typeof text === 'string') {
    chunks.push(text);
  } else if (Array.isArray(text)) {
    chunks.push(text.map(normalizePart).join(''));
  }

  if ((!chunks.length || chunks.join('').trim() === '') && Array.isArray(toolCalls)) {
    for (const call of toolCalls) {
      if (call?.function?.result && typeof call.function.result === 'string') {
        chunks.push(call.function.result);
      }
    }
  }

  const combined = chunks.join('\n').trim();
  return combined;
}

function makeTermRegex(term){
  const escaped = escapeRegExp(term.trim());
  if (!escaped) return null;
  if (/\s/.test(term)) {
    return new RegExp(escaped.replace(/\s+/g, '\\s+'), 'i');
  }
  return new RegExp(`\\b${escaped}\\b`, 'i');
}

function persistInputToStorage(element, key, { trim = true } = {}) {
  if (!element) return;
  const handler = () => {
    const raw = trim ? element.value.trim() : element.value;
    if (raw) {
      localStorage.setItem(key, raw);
    } else {
      localStorage.removeItem(key);
    }
  };
  element.addEventListener('change', handler);
  element.addEventListener('blur', handler);
}

function findMissingTerms(content, words, variantPairs = []){
  const text = content.replace(/\*\*/g, '');
  const usedVariants = new Set();
  const variantRegex = /\*\*(.*?)\*\*/g;
  let match;
  while ((match = variantRegex.exec(content)) !== null) {
    const used = match[1]?.trim().toLowerCase();
    if (used) usedVariants.add(used);
  }

  const variantMap = new Map();
  if (Array.isArray(variantPairs)) {
    for (const entry of variantPairs) {
      if (!entry || typeof entry !== 'object') continue;
      const original = typeof entry.original === 'string' ? entry.original.trim().toLowerCase() : '';
      const used = typeof entry.used === 'string' ? entry.used.trim().toLowerCase() : '';
      if (original && used) variantMap.set(original, used);
      if (original && !used) variantMap.set(original, original);
    }
  }

  const missing = [];
  for (const word of words){
    const originalLower = typeof word === 'string' ? word.trim().toLowerCase() : '';
    if (!originalLower) continue;
    if (usedVariants.has(originalLower)) continue;
    const mappedVariant = variantMap.get(originalLower);
    if (mappedVariant && usedVariants.has(mappedVariant)) continue;
    const regex = makeTermRegex(word);
    if (!regex) continue;
    if (!regex.test(text)){
      missing.push(word);
    }
  }
  return missing;
}

function setGeneratorStatus(message, kind = 'info'){
  if (!generatorStatusEl) return;
  const palette = {
    info: 'var(--muted)',
    ok: 'var(--ok)',
    warn: 'var(--warn)'
  };
  generatorStatusEl.textContent = message || '';
  generatorStatusEl.style.color = palette[kind] || palette.info;
}

persistInputToStorage(apiUrlInput, 'ai-api-url');
persistInputToStorage(apiKeyInput, 'ai-api-key');
persistInputToStorage(aiModelInput, 'ai-model');
persistInputToStorage(scoreApiUrlInput, 'score-api-url');

function setStartGradeButton(text, disabled){
  if (!startGradeBtn) return;
  if (typeof text === 'string') startGradeBtn.textContent = text;
  if (typeof disabled === 'boolean') startGradeBtn.disabled = disabled;
}

function resetStartGradeButton(){
  if (!startGradeBtn) return;
  startGradeBtn.disabled = false;
  startGradeBtn.textContent = startGradeBtn.dataset.originalText || 'üìù ÂºÄÂßãÂà§È¢ò';
}

function setSyncStatus(message, kind = 'info'){
  if (!syncStatusEl) return;
  syncStatusEl.classList.remove('ok', 'warn');
  if (kind === 'ok') syncStatusEl.classList.add('ok');
  if (kind === 'warn') syncStatusEl.classList.add('warn');
  if (kind !== 'ok' && kind !== 'warn') syncStatusEl.classList.remove('ok', 'warn');
  syncStatusEl.textContent = message || '';
}

function escapeHtml(str){
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function renderServerScores(scores){
  if (!serverScoresEl) return;
  if (!scores || !scores.length){
    serverScoresEl.innerHTML = '<div class="empty">ÊúçÂä°Âô®ÊöÇÊó†ËØçÊ±áËÆ∞ÂΩï„ÄÇ</div>';
    return;
  }

  const rows = scores.map(({ term, score, submissions, last_submission: lastSubmission }) => {
    const safeTerm = escapeHtml(term);
    const val = Number(score);
    const displayScore = Number.isFinite(val) ? val.toFixed(2) : '0.00';
    const submissionCount = Number.isFinite(Number(submissions)) ? Number(submissions) : 0;
    let displayTime = '-';
    if (lastSubmission) {
      const date = new Date(lastSubmission);
      displayTime = Number.isNaN(date.getTime()) ? escapeHtml(lastSubmission) : date.toLocaleString();
    }
    return `<tr><td>${safeTerm}</td><td>${displayScore}</td><td>${submissionCount}</td><td>${escapeHtml(displayTime)}</td></tr>`;
  }).join('');

  serverScoresEl.innerHTML = `
    <h5>ÊúçÂä°Âô®ËØçË°®ÂæóÂàÜ</h5>
    <table>
      <thead><tr><th>ËØçÊ±á</th><th>Á¥ØËÆ°ÂàÜÊï∞</th><th>Êèê‰∫§Ê¨°Êï∞</th><th>ÊúÄÂêéÊèê‰∫§Êó∂Èó¥</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

function getScoreApiBase(){
  const inputVal = scoreApiUrlInput?.value?.trim();
  if (inputVal) return inputVal;
  const stored = localStorage.getItem('score-api-url');
  if (stored) return stored;
  return 'http://localhost:4000';
}

function collectSimilarityPayload(){
  const results = [];
  if (!LAST_GRADING_RESULTS) return results;
  for (const [term, data] of Object.entries(LAST_GRADING_RESULTS)){
    if (!data) continue;
    if (typeof data.similarity === 'number'){
      const context = TERM_CONTEXTS.get(term) || '';
      results.push({
        term,
        similarity: data.similarity,
        context: context || null
      });
    }
  }
  return results;
}

function getCurrentArticleMarkdown(){
  if (typeof CURRENT_ARTICLE_MARKDOWN === 'string' && CURRENT_ARTICLE_MARKDOWN.trim()) {
    return CURRENT_ARTICLE_MARKDOWN.trim();
  }
  const editorValue = typeof articleEditor?.value === 'string' ? articleEditor.value.trim() : '';
  return editorValue;
}

function collectSuggestionCounts(){
  const practicedRaw = Number(practicedCountInput?.value ?? 0);
  const totalRaw = Number(totalCountInput?.value ?? 0);
  const thresholdRaw = Number(masteryThresholdInput?.value ?? 1);
  const practiced = Number.isFinite(practicedRaw) ? Math.max(0, Math.min(50, Math.round(practicedRaw))) : 0;
  const total = Number.isFinite(totalRaw) ? Math.max(0, Math.min(50, Math.round(totalRaw))) : 0;
  const masteryThreshold = Number.isFinite(thresholdRaw) ? thresholdRaw : 1;
  return { practiced, total, masteryThreshold };
}

async function fetchServerScores({ quiet = false } = {}) {
  try {
    const base = getScoreApiBase();
    const endpoint = base.replace(/\/$/, '') + '/api/word-scores';
    const response = await fetch(endpoint, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    });
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`HTTP ${response.status} ${response.statusText}: ${text}`);
    }
    const data = await response.json();
    if (Array.isArray(data.scores)) {
      renderServerScores(data.scores);
      if (!quiet) {
        setSyncStatus(`Â∑≤Ëé∑ÂèñÊúçÂä°Âô®ËÆ∞ÂΩïÔºà${data.scores.length} ‰∏™ËØçÔºâ`, 'ok');
      }
    } else if (!quiet) {
      setSyncStatus('ÊúçÂä°Âô®Êú™ËøîÂõûÊúâÊïàÊï∞ÊçÆ', 'warn');
    }
  } catch (error) {
    if (!quiet) {
      setSyncStatus(`Êó†Ê≥ïËé∑ÂèñÊúçÂä°Âô®ÂàÜÊï∞Ôºö${error.message}`, 'warn');
    }
  }
}

async function handleAutoFillWords(){
  if (!autoFillWordsBtn) return;
  const { practiced, total, masteryThreshold } = collectSuggestionCounts();
  if (!total){
    setGeneratorStatus('ËØ∑ËÆæÁΩÆÊÄªËØçÊï∞ÔºàËá≥Â∞ë 1Ôºâ', 'warn');
    return;
  }

  if (practiced > total){
    setGeneratorStatus('ÁªÉ‰π†ËøáÁöÑËØçÊï∞‰∏çËÉΩË∂ÖËøáÊÄªËØçÊï∞', 'warn');
    return;
  }

  const base = getScoreApiBase();
  const endpoint = `${base.replace(/\/$/, '')}/api/word-suggestions?practiced=${practiced}&total=${total}&threshold=${encodeURIComponent(masteryThreshold)}`;

  autoFillWordsBtn.disabled = true;
  autoFillWordsBtn.textContent = 'Ëé∑Âèñ‰∏≠‚Ä¶';
  setGeneratorStatus('Ê≠£Âú®ÂêëÊúçÂä°Âô®ËØ∑Ê±ÇÊé®ËçêËØçÊ±á‚Ä¶', 'info');

  try {
    const response = await fetch(endpoint, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    });
    if (!response.ok) {
      const text = await response.text();
      throw new Error(`HTTP ${response.status} ${response.statusText}: ${text}`);
    }
    const data = await response.json();
    const practicedWords = Array.isArray(data.practiced) ? data.practiced.map(entry => entry.term).filter(Boolean) : [];
    const freshWords = Array.isArray(data.fresh) ? data.fresh.map(entry => entry.term).filter(Boolean) : [];

    if (!practicedWords.length && !freshWords.length) {
      setGeneratorStatus('Êú™Ëé∑ÂèñÂà∞Á¨¶ÂêàÊù°‰ª∂ÁöÑËØçÊ±áÔºåËØ∑Ë∞ÉÊï¥ÂèÇÊï∞„ÄÇ', 'warn');
      return;
    }

    const segments = [];
    if (practicedWords.length) segments.push(practicedWords.join(', '));
    if (freshWords.length) segments.push(freshWords.join(', '));

    generatorWordsEl.value = segments.join('\n\n');
    setGeneratorStatus(`Â∑≤Â°´ÂÖ• ${practicedWords.length} ‰∏™ÁªÉ‰π†ËØç‰∏é ${freshWords.length} ‰∏™Êñ∞ËØç`, 'ok');
    localStorage.setItem('score-api-url', base);
  } catch (error) {
    console.error('[Auto Fill Words] Ëé∑ÂèñÂ§±Ë¥•:', error);
    setGeneratorStatus(`Ëé∑ÂèñÊé®ËçêËØçÊ±áÂ§±Ë¥•Ôºö${error.message}`, 'warn');
  } finally {
    autoFillWordsBtn.disabled = false;
    autoFillWordsBtn.textContent = 'üéØ Ëá™Âä®ÂèñËØç';
  }
}

function getSavedAIConfig(){
  const rawUrl = apiUrlInput?.value?.trim();
  const rawKey = apiKeyInput?.value?.trim();
  const rawModel = aiModelInput?.value?.trim();

  const storedUrl = localStorage.getItem('ai-api-url');
  const storedKey = localStorage.getItem('ai-api-key');
  const storedModel = localStorage.getItem('ai-model');

  const apiUrl = (rawUrl || storedUrl || '').trim();
  const apiKey = (rawKey || storedKey || '').trim();
  const model = (rawModel || storedModel || 'gpt-3.5-turbo').trim() || 'gpt-3.5-turbo';

  if (rawUrl !== undefined) {
    if (rawUrl) {
      localStorage.setItem('ai-api-url', rawUrl);
    } else {
      localStorage.removeItem('ai-api-url');
    }
  }

  if (rawKey !== undefined) {
    if (rawKey) {
      localStorage.setItem('ai-api-key', rawKey);
    } else {
      localStorage.removeItem('ai-api-key');
    }
  }

  if (rawModel !== undefined) {
    if (rawModel) {
      localStorage.setItem('ai-model', rawModel);
    } else {
      localStorage.removeItem('ai-model');
    }
  }

  return { apiUrl, apiKey, model };
}

function shuffleWords(list){
  const arr = [...list];
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function createArticlePrompt(words){
  const wordGoal = DEFAULT_ARTICLE_WORD_GOAL;
  const paragraphCount = DEFAULT_ARTICLE_PARAGRAPH_COUNT;
  const bulletList = words.map((w, idx) => `${idx + 1}. ${w}`).join('\n');
  return `ËØ∑ÂÜô‰∏ÄÁØáÈù¢ÂêëËã±ËØ≠Â≠¶‰π†ËÄÖÁöÑËã±ÊñáÁü≠ÊñáÔºå‰ΩøÁî® Markdown ÊÆµËêΩÊ†ºÂºèÔºà‰∏çË¶ÅÊ∑ªÂä†Ê†áÈ¢ò„ÄÅÂâçÁºÄËØ¥ÊòéÊàñ‰ª£Á†ÅÂùóÔºâ„ÄÇË¶ÅÊ±ÇÔºö\n- ÂàÜÊàê ${paragraphCount} ‰∏™ÊÆµËêΩÔºåÊÄªÂ≠óÊï∞Á∫¶ ${wordGoal} ËØç„ÄÇ\n- ‰∏ãÂàóËØçÊ±áÈ°∫Â∫èÂ∑≤ÈöèÊú∫ÊéíÂàóÔºå‰Ω†ÂèØ‰ª•Êåâ‰ªªÊÑèÈ°∫Â∫èÂÆâÊéíÂÜÖÂÆπÔºå‰ΩÜÊØè‰∏™ËØçËá≥Â∞ëÂá∫Áé∞‰∏ÄÊ¨°ÔºåÂπ∂‰ΩøÁî® Markdown Á≤ó‰Ωì **word** ÂΩ¢ÂºèÊ†áÊ≥®„ÄÇÔºàÂèØÊ†πÊçÆËØ≠Â¢ÉË∞ÉÊï¥Â§ßÂ∞èÂÜô„ÄÅÊó∂ÊÄÅÊàñËØ≠ÊÄÅ„ÄÇÔºâ\n- ÊñáÁ´†ÈúÄËá™ÁÑ∂ÊµÅÁïÖÔºåÂèØÂä†ÂÖ•ËÉåÊôØ„ÄÅ‰æãÂ≠êÊàñËß£ÈáäÔºåÁ°Æ‰øùÊâÄÊúâËØçÊ±áËûçÂÖ•ËØ≠‰πâ„ÄÇ\n\nËØ∑‰ªÖËæìÂá∫ÊñáÁ´†Ê≠£ÊñáÔºå‰øùÁïô Markdown Ê†áËÆ∞Ôºå‰∏çË¶ÅÈ¢ùÂ§ñÊ∑ªÂä†ËØ¥ÊòéÊàñJSON„ÄÇ\n\nÁõÆÊ†áËØçÊ±áÔºàÈ°∫Â∫èÈöèÊú∫ÔºâÔºö\n${bulletList}`;
}

function createVariantMappingPrompt(article, words){
  const list = words.map((w, idx) => `${idx + 1}. ${w}`).join('\n');
  return `ËØ∑ÈòÖËØª‰∏ãÊñπÁöÑËã±ÊñáÊñáÁ´†ÔºåÂπ∂Ê†πÊçÆÊèê‰æõÁöÑÁõÆÊ†áËØçÊ±áÂàóË°®ÔºåÊåáÂá∫ÊñáÁ´†‰∏≠ÊØè‰∏™ËØçÊ±áÁöÑÂÆûÈôÖÂÜôÊ≥ï„ÄÇ\n\nËæìÂá∫‰∏Ä‰∏™ JSON ÂØπË±°ÔºåÊ†ºÂºèÂ¶Ç‰∏ãÔºö\n{\n  "pairs": [\n    {"original": "ÁõÆÊ†áËØçÊ±á", "used": "ÊñáÁ´†‰∏≠ÁöÑÂÆûÈôÖÂÜôÊ≥ïÔºàÂéªÊéâ**ÔºåËã•Êú™Âá∫Áé∞ÂàôÁïôÁ©∫Â≠óÁ¨¶‰∏≤Ôºâ"}\n  ]\n}\n\nË¶ÅÊ±ÇÔºö\n- original ÂøÖÈ°ª‰∏éÊèê‰æõÁöÑÁõÆÊ†áËØçÊ±áÂÆåÂÖ®‰∏ÄËá¥Ôºõ\n- used ‰∏∫ÊñáÁ´†‰∏≠Âá∫Áé∞ÁöÑÂÖ∑‰ΩìÂΩ¢ÂºèÔºà‰øùÁïôÂ§ßÂ∞èÂÜô/ÂçïÂ§çÊï∞Á≠âÂèòÂåñÔºå‰ΩÜÂéªÊéâ‰ªª‰Ωï Markdown ** Ê†áËÆ∞ÔºâÔºõ\n- Â¶ÇÊûúÊüê‰∏™ËØçÊú™Âú®ÊñáÁ´†‰∏≠Âá∫Áé∞ÔºåÂ∞Ü used ËÆæ‰∏∫Á©∫Â≠óÁ¨¶‰∏≤„ÄÇ\n\nËã±ÊñáÊñáÁ´†Ôºö\n"""\n${article}\n"""\n\nÁõÆÊ†áËØçÊ±áÂàóË°®Ôºö\n${list}`;
}

function cleanVariantValue(value){
  if (typeof value !== 'string') return '';
  return value.replace(/\*\*/g, '').trim();
}

function parseVariantMappingResponse(rawText, originalWords){
  const fallback = (originalWords || []).map(word => ({ original: word, used: word }));
  if (!rawText) return fallback;
  let text = rawText.trim();
  if (!text) return fallback;

  let jsonText = null;
  const fenced = text.match(/```(?:json)?([\s\S]*?)```/i);
  if (fenced) {
    jsonText = fenced[1].trim();
  } else {
    const match = text.match(/\{[\s\S]*\}/);
    if (match) {
      jsonText = match[0];
    }
  }

  let pairs = [];
  if (jsonText) {
    try {
      const parsed = JSON.parse(jsonText);
      const array = Array.isArray(parsed?.pairs) ? parsed.pairs : Array.isArray(parsed) ? parsed : [];
      pairs = array
        .map(entry => {
          if (!entry || typeof entry !== 'object') return null;
          const original = typeof entry.original === 'string' ? entry.original.trim() : '';
          const used = cleanVariantValue(entry.used ?? '');
          if (!original) return null;
          return { original, used: used || '' };
        })
        .filter(Boolean);
    } catch (error) {
      console.warn('[Variant Mapping] JSONËß£ÊûêÂ§±Ë¥•ÔºåÂ∞ùËØïËß£ÊûêÁ∫ØÊñáÊú¨Ê†ºÂºè', error);
      pairs = [];
    }
  }

  if (!pairs.length) {
    const lines = text.split(/\n+/).map(line => line.trim()).filter(Boolean);
    for (const line of lines) {
      const match = line.match(/^(.+?)\s*(?:=>|->|Ôºö|:|=)\s*(.+)$/);
      if (!match) continue;
      const original = match[1].trim();
      const used = cleanVariantValue(match[2]);
      if (original) {
        pairs.push({ original, used });
      }
    }
  }

  const normalized = new Map();
  for (const pair of pairs) {
    const original = typeof pair.original === 'string' ? pair.original.trim() : '';
    if (!original) continue;
    const key = original.toLowerCase();
    const used = cleanVariantValue(pair.used || original);
    if (!normalized.has(key)) {
      normalized.set(key, { original, used: used || original });
    }
  }

  const result = [];
  for (const original of originalWords || []) {
    const key = original.trim().toLowerCase();
    const mapped = normalized.get(key);
    const used = mapped ? mapped.used : original;
    result.push({ original, used });
  }

  return result;
}

async function requestVariantMappings(apiUrl, apiKey, model, article, words){
  const prompt = createVariantMappingPrompt(article, words);
  const body = {
    model,
    messages: [
      {
        role: 'system',
        content: 'You are an assistant that extracts vocabulary mappings and responds with concise JSON.'
      },
      { role: 'user', content: prompt }
    ],
    temperature: 0,
    max_tokens: 3000
  };

  console.log('[Variant Mapping] ËØ∑Ê±Ç‰Ωì:', JSON.stringify(body, null, 2));

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(body)
  });

  console.log('[Variant Mapping] ÂìçÂ∫îÁä∂ÊÄÅ:', response.status, response.statusText);
  if (!response.ok) {
    const errorText = await response.text();
    console.error('[Variant Mapping] APIÈîôËØØÂìçÂ∫î:', errorText);
    throw new Error(`ËØçÂΩ¢Êò†Â∞ÑËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}: ${errorText}`);
  }

  const result = await response.json();
  console.log('[Variant Mapping] APIÂìçÂ∫î:', result);
  const message = result?.choices?.[0]?.message;
  if (!message) {
    throw new Error('ËØçÂΩ¢Êò†Â∞ÑÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏');
  }
  const text = extractMessageText(message);
  console.log('[Variant Mapping] AIÂõûÂ§ç:', text);
  return parseVariantMappingResponse(text, words);
}

async function handleGenerateArticle(){
  if (!generateArticleBtn) return;
  const words = parseGeneratorWords(generatorWordsEl?.value || '');
  if (!words.length){
    setGeneratorStatus('ËØ∑Ëá≥Â∞ëËæìÂÖ•‰∏Ä‰∏™ÁõÆÊ†áËØçÊ±á', 'warn');
    generatorWordsEl?.focus();
    return;
  }

  const { apiUrl, apiKey, model } = getSavedAIConfig();

  if (!apiUrl || !apiKey){
    setGeneratorStatus('ËØ∑ÂÖàÂú®Âè≥‰æßÈÖçÁΩÆAI APIÂú∞ÂùÄ‰∏éKey', 'warn');
    return;
  }

  const originalLabel = generateArticleBtn.dataset.originalText || generateArticleBtn.textContent;

  try {
    generateArticleBtn.disabled = true;
    generateArticleBtn.dataset.originalText = originalLabel;
    generateArticleBtn.textContent = 'ÁîüÊàê‰∏≠‚Ä¶';
    setGeneratorStatus('Ê≠£Âú®ËØ∑Ê±ÇAIÁîüÊàêÊñáÁ´†‚Ä¶', 'info');

    const shuffledWords = shuffleWords(words);
    const prompt = createArticlePrompt(shuffledWords);
    const body = {
      model,
      messages: [
        {
          role: 'system',
          content: 'You are an expert science writer who produces fluent, engaging English articles in Markdown without extra commentary.'
        },
        { role: 'user', content: prompt }
      ],
      temperature: 0.65,
      top_p: 0.9,
      max_tokens: Math.min(1200, Math.round(DEFAULT_ARTICLE_WORD_GOAL * 4.2))
    };

    console.log('[Article Generator] ËØ∑Ê±Ç‰Ωì:', JSON.stringify(body, null, 2));

    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify(body)
    });

    if (!response.ok){
      const errorText = await response.text();
      throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText} | ${errorText}`);
    }

    const result = await response.json();
    console.log('[Article Generator] APIÂìçÂ∫î:', result);
    const message = result?.choices?.[0]?.message;
    if (!message) {
      throw new Error('AIÊú™ËøîÂõûÊñáÁ´†ÂÜÖÂÆπ');
    }
    const article = extractMessageText(message);
    if (!article) {
      throw new Error('AIÊú™ËøîÂõûÊñáÁ´†ÂÜÖÂÆπ');
    }

    articleEditor.value = article.trim();

    let variants;
    let mappingFailed = false;
    try {
      setGeneratorStatus('ÊñáÁ´†ÁîüÊàêÊàêÂäüÔºåÊ≠£Âú®ÂàÜÊûêËØçÂΩ¢Êò†Â∞Ñ‚Ä¶', 'info');
      variants = await requestVariantMappings(apiUrl, apiKey, model, article, words);
      if (!Array.isArray(variants) || !variants.length) {
        throw new Error('Êú™Ëé∑ÂæóÊúâÊïàÁöÑËØçÂΩ¢Êò†Â∞Ñ');
      }
    } catch (mappingError) {
      console.error('[Article Generator] ËØçÂΩ¢Êò†Â∞ÑÂ§±Ë¥•:', mappingError);
      variants = words.map(original => ({ original, used: original }));
      setGeneratorStatus('ÊñáÁ´†ÁîüÊàêÂÆåÊàêÔºå‰ΩÜËØçÂΩ¢Êò†Â∞ÑÂ§±Ë¥•ÔºåÂ∑≤‰ΩøÁî®ÂéüÂßãËØçÊ±á„ÄÇ', 'warn');
      toast('ËØçÂΩ¢Êò†Â∞ÑÂ§±Ë¥•ÔºåÂ∑≤‰ΩøÁî®ÂéüÂßãËØçÊ±á', 'warn');
      mappingFailed = true;
    }

    console.log('[Article Generator] ÊúÄÁªàËØçÂΩ¢Êò†Â∞Ñ:', variants);

    processArticleContent(article, variants);
    switchToViewMode();
    const missingTerms = findMissingTerms(article, words, variants);
    if (missingTerms.length){
      const message = `‚ö†Ô∏è Â∑≤ÁîüÊàêÊñáÁ´†Ôºå‰ΩÜÁº∫Â∞ë ${missingTerms.length} ‰∏™ËØçÔºö${missingTerms.join('Ôºå')}`;
      setGeneratorStatus(message, 'warn');
      toast('ÁîüÊàêÂÆåÊàêÔºå‰ΩÜÂ≠òÂú®Áº∫Â§±ËØçÊ±áÔºåËØ∑ÊâãÂä®Ë°•ÂÖÖ„ÄÇ', 'warn');
    } else if (!mappingFailed) {
      setGeneratorStatus('AIÊñáÁ´†ÁîüÊàêÂÆåÊàêÔºåËØçÊ±á‰∏éËØçÂΩ¢ÂùáÂ∑≤Ë¶ÜÁõñ ‚úì', 'ok');
      toast('ÊñáÁ´†ÁîüÊàêÊàêÂäüÂπ∂ÂåÖÂê´ÂÖ®ÈÉ®ÁõÆÊ†áËØçÊ±áÔºÅ', 'ok');
    }
  } catch (error) {
    console.error('[Article Generator] ÁîüÊàêÊñáÁ´†Â§±Ë¥•:', error);
    setGeneratorStatus(`ÁîüÊàêÂ§±Ë¥•Ôºö${error.message}`, 'warn');
  } finally {
    generateArticleBtn.disabled = false;
    generateArticleBtn.textContent = generateArticleBtn.dataset.originalText || '‚ú® AIÁîüÊàêÊñáÁ´†';
  }
}


// Process article content and extract vocabulary
function processArticleContent(content, variantPairs = []) {
  try {
    CURRENT_ARTICLE_MARKDOWN = typeof content === 'string' ? content : '';
    resetVariantMappings(variantPairs);
    // Convert **markdown** to <strong> HTML tags and preserve paragraph structure
    const formattedContent = convertMarkdownToHtml(content);

    // Display the article content
    articleContent.innerHTML = formattedContent;

    // Extract vocabulary from ** marked words
    extractVocabulary(content);
    updateTermContextsFromArticle();

    // Rebuild vocabulary list
    buildList();

    editorStatus.textContent = 'ÊñáÁ´†‰øùÂ≠òÊàêÂäüÔºÅ';
    editorStatus.style.color = 'var(--ok)';
  } catch (error) {
    editorStatus.textContent = 'Â§ÑÁêÜÊñáÁ´†ÂÜÖÂÆπÊó∂Âá∫Èîô: ' + error.message;
    editorStatus.style.color = 'var(--warn)';
  }
}

// Convert markdown **word** to <strong>word</strong> and preserve paragraph structure
function convertMarkdownToHtml(content) {
  // Split content into paragraphs (separated by double newlines)
  const paragraphs = content.split('\n\n');

  // Process each paragraph
  const htmlParagraphs = paragraphs.map(paragraph => {
    // Convert **word** to <strong>word</strong>
    let htmlParagraph = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    // Wrap in <p> tag
    return `<p>${htmlParagraph}</p>`;
  });

  return htmlParagraphs.join('\n');
}

// Extract vocabulary from ** marked words
function extractVocabulary(content) {
  // Find all words enclosed in **
  const regex = /\*\*(.*?)\*\*/g;
  const vocabList = [];
  const vocabSet = new Set();
  let match;
  while ((match = regex.exec(content)) !== null) {
    const used = match[1]?.trim();
    if (!used) continue;
    const original = getOriginalFromVariant(used) || used;
    registerVariantMapping(original, used);
    if (!vocabSet.has(original)) {
      vocabSet.add(original);
      vocabList.push(original);
    }
  }

  VOCABS = vocabList;
}

function updateTermContextsFromArticle() {
  TERM_CONTEXTS.clear();
  if (!articleContent) return;

  const paragraphs = articleContent.querySelectorAll('p');
  paragraphs.forEach(paragraph => {
    const paragraphText = paragraph.textContent
      ? paragraph.textContent.replace(/\s+/g, ' ').trim()
      : '';
    if (!paragraphText) return;

    const strongElements = paragraph.querySelectorAll('strong');
    strongElements.forEach(strong => {
      const variant = strong.textContent ? strong.textContent.trim() : '';
      if (!variant) return;
      const originalTerm = getOriginalFromVariant(variant) || variant;
      if (!originalTerm || TERM_CONTEXTS.has(originalTerm)) return;
      const sentence = extractSentenceFromContext(paragraphText, variant) || paragraphText;
      TERM_CONTEXTS.set(originalTerm, sentence);
    });
  });
}

function extractSentenceFromContext(paragraphText, variant) {
  if (!paragraphText || !variant) return '';
  const normalizedParagraph = paragraphText.replace(/\s+/g, ' ').trim();
  const lowerVariant = variant.trim().toLowerCase();

  const sentenceMatches = normalizedParagraph.match(/[^„ÄÇÔºÅÔºü!?\.]+[„ÄÇÔºÅÔºü!?\.]?/g) || [normalizedParagraph];
  for (const sentence of sentenceMatches) {
    if (sentence.toLowerCase().includes(lowerVariant)) {
      return sentence.trim();
    }
  }

  return normalizedParagraph;
}

// Function to find term by id fragment
function findTermByIdFragment(idFragment){
  for (const term of VOCABS) {
    const expectedId = term.toLowerCase().replace(/[^a-z0-9]+/g,'-');
    if (expectedId === idFragment) return term;
  }
  return null;
}

// Mode switching functions
function switchToEditMode() {
  editModeBtn.classList.add('active');
  viewModeBtn.classList.remove('active');
  editSection.style.display = 'block';
  viewSection.style.display = 'none';
}

function switchToViewMode() {
  editModeBtn.classList.remove('active');
  viewModeBtn.classList.add('active');
  editSection.style.display = 'none';
  viewSection.style.display = 'block';
}

// Mode switching event listeners
editModeBtn.addEventListener('click', switchToEditMode);
viewModeBtn.addEventListener('click', switchToViewMode);

// Save article event listener
saveArticleBtn.addEventListener('click', () => {
  const content = articleEditor.value;
  if (content.trim()) {
    processArticleContent(content);
    switchToViewMode();
  } else {
    editorStatus.textContent = 'ËØ∑ËæìÂÖ•ÊñáÁ´†ÂÜÖÂÆπ';
    editorStatus.style.color = 'var(--warn)';
  }
});

if (generateArticleBtn){
  generateArticleBtn.addEventListener('click', handleGenerateArticle);
}

if (autoFillWordsBtn){
  autoFillWordsBtn.addEventListener('click', (e) => {
    e.preventDefault();
    handleAutoFillWords();
  });
}

if (syncServerBtn){
  syncServerBtn.addEventListener('click', async () => {
    const payload = collectSimilarityPayload();
    if (!payload.length){
      setSyncStatus('ËØ∑ÂÖàÂÆåÊàêAIÂà§È¢òÂêéÂÜçÂêåÊ≠•„ÄÇ', 'warn');
      toast('Ê≤°ÊúâÂèØÂêåÊ≠•ÁöÑÂà§È¢òÂàÜÊï∞', 'warn');
      return;
    }

    const base = getScoreApiBase();
    const endpoint = base.replace(/\/$/, '') + '/api/word-scores';
    const articleMarkdown = getCurrentArticleMarkdown();
    const originalLabel = syncServerBtn.dataset.originalText || syncServerBtn.textContent;
    syncServerBtn.dataset.originalText = originalLabel;
    syncServerBtn.disabled = true;
    syncServerBtn.textContent = 'ÂêåÊ≠•‰∏≠‚Ä¶';
    setSyncStatus('Ê≠£Âú®ÂêåÊ≠•Âà§È¢òÁªìÊûúÂà∞ÊúçÂä°Âô®‚Ä¶', 'info');

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ results: payload, article: articleMarkdown })
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(`HTTP ${response.status} ${response.statusText}: ${text}`);
      }

      const data = await response.json();
      const scores = Array.isArray(data.scores) ? data.scores : [];
      renderServerScores(scores);
      const updatedCount = data.updated ?? payload.length;
      setSyncStatus(`ÂêåÊ≠•ÊàêÂäüÔºåÂ∑≤Êõ¥Êñ∞ ${updatedCount} ‰∏™ËØçÊ±á`, 'ok');
      toast('ÊúçÂä°Âô®ËØçË°®Â∑≤Êõ¥Êñ∞ ‚úì', 'ok');
      localStorage.setItem('score-api-url', base);
    } catch (error) {
      console.error('[Sync Scores] ÂêåÊ≠•Â§±Ë¥•:', error);
      setSyncStatus(`ÂêåÊ≠•Â§±Ë¥•Ôºö${error.message}`, 'warn');
      toast('ÂêåÊ≠•Â§±Ë¥•Ôºö' + error.message, 'warn');
    } finally {
      syncServerBtn.disabled = false;
      syncServerBtn.textContent = syncServerBtn.dataset.originalText || '‚¨ÜÔ∏è ÂêåÊ≠•Âà∞ÊúçÂä°Âô®';
    }
  });
}

// Function to jump to and highlight input field
function jumpToInput(term){
  const inputEl = document.getElementById(makeId(term));
  if (inputEl) {
    inputEl.scrollIntoView({behavior:'smooth', block:'center'});
    inputEl.focus();
    // Highlight the input's parent item
    const itemEl = inputEl.closest('.item');
    if (itemEl) {
      itemEl.style.outline = '2px solid var(--accent-2)';
      itemEl.style.boxShadow = '0 0 0 4px rgba(137,220,235,.25)';
      setTimeout(()=>{
        itemEl.style.outline = '';
        itemEl.style.boxShadow='';
      }, 1500);
    }
  }
}

function buildList(){
  listEl.innerHTML = '';
  const q = filterEl.value?.trim().toLowerCase();
  for (const term of VOCABS){
    if (q && !term.toLowerCase().includes(q)) continue;
    const id = makeId(term);
    const div = document.createElement('div');
    div.className = 'item';
    div.innerHTML = `
      <div class="term" data-term="${term}">
        <span>${term}</span>
        <span class="jump" data-term="${term}">Ë∑≥Âà∞Êñá‰∏≠</span>
      </div>
      <input aria-label="${term} ‰∏≠ÊñáÊÑèÊÄù" placeholder="‰∏≠ÊñáÊÑèÊÄù‚Ä¶" id="${id}" data-term="${term}" />
    `;
    listEl.appendChild(div);
  }
}

// Initialize
buildList();

// Delegated jump - both term and jump button work
listEl.addEventListener('click', (e)=>{
  const t = e.target;
  if (t.classList.contains('jump')){
    jumpTo(t.dataset.term);
  } else if (t.classList.contains('term') || t.parentElement.classList.contains('term')){
    const term = t.dataset.term || t.parentElement.dataset.term;
    if (term) jumpTo(term);
  }
});

filterEl.addEventListener('input', buildList);

// Add focus event listener for input fields
listEl.addEventListener('focus', (e)=>{
  if (e.target.tagName === 'INPUT' && e.target.dataset.term) {
    jumpTo(e.target.dataset.term);
  }
}, true);

// Add click handler for article words to jump to corresponding input
document.getElementById('article-content').addEventListener('click', (e)=>{
  if (e.target.tagName === 'STRONG') {
    const variant = e.target.textContent.trim();
    const originalTerm = getOriginalFromVariant(variant);
    if (originalTerm && VOCABS.includes(originalTerm)) {
      jumpToInput(originalTerm);
    }
  }
});

// Persistence helpers
const KEY = 'geo_vocab_answers_v1';

function gather(){
  const data = {};
  for (const term of VOCABS){
    const el = document.getElementById(makeId(term));
    data[term] = el ? (el.value || '') : '';
  }
  return data;
}

function fill(data){
  if (!data) return;
  for (const term of VOCABS){
    const el = document.getElementById(makeId(term));
    if (el && term in data) el.value = data[term] || '';
  }
}

function persistAnswers(){
  try {
    const data = gather();
    localStorage.setItem(KEY, JSON.stringify(data));
  } catch (error) {
    console.warn('[Persist Answers] ‰øùÂ≠òÂ§±Ë¥•:', error);
  }
}

let answerSaveTimer = null;
function schedulePersistAnswers(){
  if (answerSaveTimer) clearTimeout(answerSaveTimer);
  answerSaveTimer = setTimeout(() => {
    answerSaveTimer = null;
    persistAnswers();
  }, 300);
}

// Auto-load if present
try {
  const saved = JSON.parse(localStorage.getItem(KEY) || 'null');
  fill(saved);
} catch {}

listEl.addEventListener('input', (event) => {
  const target = event.target;
  if (target instanceof HTMLInputElement && target.dataset.term) {
    schedulePersistAnswers();
  }
});

document.getElementById('clear').addEventListener('click', ()=>{
  for (const term of VOCABS){
    const el = document.getElementById(makeId(term));
    if (el) el.value = '';
  }
  persistAnswers();
  toast('Â∑≤Ê∏ÖÁ©∫ËæìÂÖ•', 'warn');
});


// Toast notification
function toast(msg, kind){
  const t = document.createElement('div');
  t.textContent = msg;
  t.style.position='fixed';
  t.style.right='18px';
  t.style.bottom='18px';
  t.style.background = 'rgba(10,15,30,.95)';
  t.style.border='1px solid rgba(122,162,247,.3)';
  t.style.color = kind==='ok' ? 'var(--ok)' : (kind==='warn'? 'var(--warn)' : 'var(--text)');
  t.style.padding = '10px 12px';
  t.style.borderRadius='10px';
  t.style.boxShadow='0 6px 18px var(--shadow)';
  document.body.appendChild(t);
  setTimeout(()=>t.remove(), 2200);
}

// AI Grading System
let gradingInProgress = false;
const aiConfigEl = document.getElementById('ai-config');
const aiResultsEl = document.getElementById('ai-results');
const aiProgressEl = document.getElementById('ai-progress');
const progressFillEl = document.getElementById('progress-fill');
const progressTextEl = document.getElementById('progress-text');
const scoreSummaryEl = document.getElementById('score-summary');
const aiIdentityCheckBtn = document.getElementById('ai-identity-check');

// AI Grading Event Listeners
document.getElementById('ai-grade').addEventListener('click', async () => {
  if (aiConfigEl.style.display === 'none') {
    aiConfigEl.style.display = 'block';
    setGeneratorStatus('');
    // Load saved API settings
    const savedApiUrl = localStorage.getItem('ai-api-url');
    const savedApiKey = localStorage.getItem('ai-api-key');
    const savedModel = localStorage.getItem('ai-model') || 'gpt-3.5-turbo';
    if (savedApiUrl) document.getElementById('api-url').value = savedApiUrl;
    if (savedApiKey) document.getElementById('api-key').value = savedApiKey;
    document.getElementById('ai-model').value = savedModel;
    const savedScoreApi = localStorage.getItem('score-api-url');
    if (scoreApiUrlInput) {
      scoreApiUrlInput.value = savedScoreApi || scoreApiUrlInput.value || 'http://localhost:4000';
    }
    renderServerScores([]);
    setSyncStatus('ÂêåÊ≠•ÂêéÂ∞ÜÊòæÁ§∫Êú¨Ê¨°Êèê‰∫§ÁöÑËØçÊ±áÊàêÁª©', 'info');
  } else {
    aiConfigEl.style.display = 'none';
  }
});

// AI Identity Check Button
aiIdentityCheckBtn.addEventListener('click', async () => {
  const { apiUrl, apiKey, model } = getSavedAIConfig();

  if (!apiUrl || !apiKey) {
    alert('ËØ∑ÂÖàÈÖçÁΩÆAPIÂú∞ÂùÄÂíåKeyÔºÅ\n\nÁÇπÂáª"ü§ñ AIÂ∑•ÂÖ∑ÁÆ±"ÊåâÈíÆËøõË°åÈÖçÁΩÆ„ÄÇ');
    return;
  }

  aiIdentityCheckBtn.textContent = 'üîç Ê£ÄÊµã‰∏≠...';
  aiIdentityCheckBtn.disabled = true;

  try {
    const identity = await checkAIIdentityForDisplay(apiUrl, apiKey, model);
    // Show result in alert
    alert(`AIË∫´‰ªΩ‰ø°ÊÅØÔºö\n\n${identity}`);
  } catch (error) {
    alert(`AIË∫´‰ªΩÊ£ÄÊµãÂ§±Ë¥•Ôºö\n\n${error.message}`);
  } finally {
    aiIdentityCheckBtn.textContent = 'üîç Ê£ÄÊµãAIË∫´‰ªΩ';
    aiIdentityCheckBtn.disabled = false;
  }
});

document.getElementById('cancel-grade').addEventListener('click', () => {
  aiConfigEl.style.display = 'none';
  gradingInProgress = false;
});

if (startGradeBtn) {
  startGradeBtn.addEventListener('click', async () => {
    const { apiUrl, apiKey, model } = getSavedAIConfig();

    if (!apiUrl || !apiKey) {
      aiConfigEl.style.display = 'block';
      toast('ËØ∑Â°´ÂÜôAPIÂú∞ÂùÄÂíåKey', 'warn');
      return;
    }

    const originalLabel = startGradeBtn.dataset.originalText || startGradeBtn.textContent;
    startGradeBtn.dataset.originalText = originalLabel;
    setStartGradeButton('Âà§È¢òÂáÜÂ§á‰∏≠‚Ä¶', true);

    try {
      await startAIGrading(apiUrl, apiKey, model);
    } finally {
      setTimeout(resetStartGradeButton, 600);
    }
  });
}

// Main AI grading function
async function startAIGrading(apiUrl, apiKey, model = 'gpt-3.5-turbo') {
  console.log('[Main Grading] ÂºÄÂßãAIÂà§È¢òÊµÅÁ®ã');
  console.log('[Main Grading] API URL:', apiUrl);
  console.log('[Main Grading] Ê®°Âûã:', model);
  console.log('[Main Grading] API Key ÈïøÂ∫¶:', apiKey ? apiKey.length : 0);

  if (gradingInProgress) {
    console.warn('[Main Grading] Âà§È¢òÂ∑≤Âú®ËøõË°å‰∏≠ÔºåË∑≥Ëøá');
    return;
  }

  gradingInProgress = true;
  aiProgressEl.style.display = 'block';
  aiResultsEl.style.display = 'none';

  // Clear previous results
  clearGradingResults();

  try {
    const data = gather();
    console.log('[Main Grading] Êî∂ÈõÜÁöÑÊï∞ÊçÆ:', data);

    const filledTerms = VOCABS.filter(term => data[term] && data[term].trim());
    console.log('[Main Grading] Â∑≤Â°´ÂÜôÁöÑËØçÊ±á:', filledTerms);
    console.log('[Main Grading] Â∑≤Â°´ÂÜôËØçÊ±áÊï∞Èáè:', filledTerms.length);

    if (filledTerms.length === 0) {
      console.warn('[Main Grading] Ê≤°ÊúâÂ°´ÂÜôÁöÑËØçÊ±á');
      toast('ËØ∑ÂÖàÂ°´ÂÜô‰∏Ä‰∫õÁ≠îÊ°à', 'warn');
      gradingInProgress = false;
      aiProgressEl.style.display = 'none';
      return;
    }

    progressTextEl.textContent = `ÂºÄÂßãÂà§È¢ò... (ÂÖ±${filledTerms.length}‰∏™ËØç)`;
    if (startGradeBtn) {
      setStartGradeButton(`Âà§È¢ò‰∏≠ 0/${filledTerms.length}`, true);
    }

    // Process in batches of 50
    const batchSize = 50;
    const batches = [];
    for (let i = 0; i < filledTerms.length; i += batchSize) {
      batches.push(filledTerms.slice(i, i + batchSize));
    }
    console.log('[Main Grading] ÂàÜÊâπÂ§ÑÁêÜ:', batches.length, '‰∏™ÊâπÊ¨°');

    let totalProcessed = 0;
    const results = {};

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      console.log(`[Main Grading] Â§ÑÁêÜÁ¨¨${i+1}Êâπ:`, batch);
      progressTextEl.textContent = `Ê≠£Âú®Â§ÑÁêÜÁ¨¨${i+1}/${batches.length}Êâπ (${batch.length}‰∏™ËØç)...`;

      try {
        const batchResults = await gradeBatch(batch, data, apiUrl, apiKey, model);
        console.log(`[Main Grading] Á¨¨${i+1}ÊâπÁªìÊûú:`, batchResults);
        Object.assign(results, batchResults);
        totalProcessed += batch.length;

        const progress = (totalProcessed / filledTerms.length) * 100;
        progressFillEl.style.width = progress + '%';
        console.log(`[Main Grading] ËøõÂ∫¶: ${progress}% (${totalProcessed}/${filledTerms.length})`);
        if (startGradeBtn) {
          const percentLabel = Math.round(progress);
          setStartGradeButton(`Âà§È¢ò‰∏≠ ${totalProcessed}/${filledTerms.length} (${percentLabel}%)`, true);
        }

        // Small delay between batches to avoid rate limiting
        if (i < batches.length - 1) {
          console.log(`[Main Grading] Á≠âÂæÖ1ÁßíÈÅøÂÖçÈ¢ëÁéáÈôêÂà∂`);
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      } catch (error) {
        console.error(`[Main Grading] Á¨¨${i+1}ÊâπÂ§ÑÁêÜÂ§±Ë¥•:`, error);
        toast(`Á¨¨${i+1}ÊâπÂ§ÑÁêÜÂ§±Ë¥•: ${error.message}`, 'warn');
      }
    }

    console.log('[Main Grading] ÊâÄÊúâÊâπÊ¨°Â§ÑÁêÜÂÆåÊàêÔºåÊúÄÁªàÁªìÊûú:', results);
    // Display results
    displayGradingResults(results, filledTerms.length);
    if (startGradeBtn) {
      setStartGradeButton('Âà§È¢òÂÆåÊàê ‚úì', true);
    }

  } catch (error) {
    console.error('[Main Grading] Âà§È¢òËøáÁ®ãÈîôËØØ:', error);
    toast('Âà§È¢òËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: ' + error.message, 'warn');
    if (startGradeBtn) setStartGradeButton('Âà§È¢òÂ§±Ë¥•', true);
  } finally {
    gradingInProgress = false;
    aiProgressEl.style.display = 'none';
    console.log('[Main Grading] Âà§È¢òÊµÅÁ®ãÁªìÊùü');
  }
}

// Grade a batch of words
async function gradeBatch(terms, data, apiUrl, apiKey, model = 'gpt-3.5-turbo') {
  console.log(`[Batch Grading] ÂºÄÂßãÂ§ÑÁêÜÊâπÊ¨°:`, terms);
  console.log(`[Batch Grading] ‰ΩøÁî®Ê®°Âûã:`, model);

  const prompt = createGradingPrompt(terms, data);
  console.log(`[Batch Grading] ÁîüÊàêÁöÑÊèêÁ§∫ËØç:`, prompt);

  const requestBody = {
    model: model,
    messages: [{
      role: 'user',
      content: prompt
    }],
    temperature: 0.1
  };

  console.log(`[Batch Grading] ËØ∑Ê±Ç‰Ωì:`, JSON.stringify(requestBody, null, 2));

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  console.log(`[Batch Grading] ÂìçÂ∫îÁä∂ÊÄÅ:`, response.status, response.statusText);

  if (!response.ok) {
    const errorText = await response.text();
    console.error(`[Batch Grading] APIÈîôËØØÂìçÂ∫î:`, errorText);
    throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}: ${errorText}`);
  }

  const result = await response.json();
  console.log(`[Batch Grading] APIÂìçÂ∫î:`, result);

  const message = result?.choices?.[0]?.message;
  if (!message) {
    console.error(`[Batch Grading] ÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏:`, result);
    throw new Error('APIÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏');
  }

  const aiResponse = extractMessageText(message);
  console.log(`[Batch Grading] AIÂõûÂ§çÂÜÖÂÆπ:`, aiResponse);

  const parsedResults = parseGradingResponse(aiResponse, terms);
  console.log(`[Batch Grading] Ëß£ÊûêÁªìÊûú:`, parsedResults);

  return parsedResults;
}

function clampSimilarity(value) {
  const num = typeof value === 'number' ? value : parseFloat(value);
  if (!Number.isFinite(num)) return null;
  const clamped = Math.min(Math.max(num, 0), 1);
  return Math.round(clamped * 1000) / 1000;
}

// Create grading prompt for AI
function createGradingPrompt(terms, data) {
  const termsList = terms.map(term => {
    const contextRaw = TERM_CONTEXTS.get(term) || 'ÔºàÂéüÊñáÊú™Êèê‰æõËØ≠Â¢ÉÔºâ';
    const context = contextRaw.replace(/\s+/g, ' ').trim();
    const answer = data[term] && data[term].trim() ? data[term].trim() : '(Á©∫ÁôΩ)';
    return `- Ëã±ÊñáËØçÊ±á: ${term}\n  ÂéüÊñáËØ≠Â¢É: ${context}\n  Â≠¶ÁîüÁøªËØë: ${answer}`;
  }).join('\n');

  return `‰Ω†ÊòØ‰∏ÄÂêçÁ≤æÈÄö‰∏≠Ëã±ÊñáÊúØËØ≠ÁöÑÊïôÂ∏àÔºåÈúÄË¶ÅÂà§Êñ≠Â≠¶ÁîüÁªôÂá∫ÁöÑ‰∏≠ÊñáÁøªËØë‰∏éËã±ÊñáÊúØËØ≠ÁöÑËØ≠‰πâÁõ∏‰ººÂ∫¶„ÄÇËØ∑ËÅöÁÑ¶ËØç‰πâÊú¨Ë∫´Ôºå‰∏çË¶ÅË¥¥ÂêàÁâπÂÆöÂ≠¶ÁßëËÉåÊôØÊàñÂÜ∑ÂÉªÁü•ËØÜ„ÄÇ

ËØ∑ÂØπÊØè‰∏™ËØçÊ±áÔºö
1. ÁªôÂá∫ÊúÄÊ†áÂáÜ„ÄÅÊúÄÂ∏∏Áî®ÁöÑ‰∏≠ÊñáÁøªËØëÔºàÂèØÂåÖÂê´Â§ö‰∏™ËØçÔºåÁ°Æ‰øùÂê´‰πâÂáÜÁ°ÆÔºâ„ÄÇ
2. ËØÑ‰º∞Â≠¶ÁîüÁ≠îÊ°à‰∏éÊ†áÂáÜÁ≠îÊ°àÂú®ËØ≠‰πâ‰∏äÁöÑÁõ∏‰ººÂ∫¶ÔºåÁõ∏‰ººÂ∫¶Áî® 0~1 ÁöÑÂ∞èÊï∞Ë°®Á§∫Ôºö0 ‰ª£Ë°®ÂÆåÂÖ®ÈîôËØØÔºå1 ‰ª£Ë°®ÂÆåÂÖ®‰∏ÄËá¥„ÄÇÂÖÅËÆ∏‰øùÁïô‰∏â‰ΩçÂ∞èÊï∞„ÄÇ
   - Ëã•Â≠¶ÁîüÁ≠îÊ°àÊ∂µÁõñ‰∫Ü‰∏ªË¶ÅÂê´‰πâÊàñÊèê‰æõ‰∫ÜÂ∏∏ËßÅËøë‰πâËØçÔºåÂç≥‰ΩøÊú™ÂàóÂá∫ÂÖ®ÈÉ®Èáä‰πâÔºå‰πüÂ∫îÁªô‰∫àËæÉÈ´òÂàÜÔºà‰æãÂ¶Ç ‚â•0.7Ôºâ„ÄÇ
3. Â¶ÇÊúâÈúÄË¶ÅÔºåÂèØÁªôÂá∫ÁÆÄÁü≠ËØ¥ÊòéÔºà10~25‰∏™Â≠óÔºâÔºåËß£Èáä‰∏ªË¶ÅÂ∑ÆÂºÇÊàñÂåπÈÖç‰∫ÆÁÇπ„ÄÇ

Âú®ËØÑ‰º∞Êó∂ËØ∑ÁªìÂêàÊèê‰æõÁöÑÂéüÊñáËØ≠Â¢ÉÁêÜËß£ÊúØËØ≠ÁöÑÂê´‰πâÔºå‰ª•ËØ•ËØ≠Â¢É‰∏∫ÂáÜÂà§Êñ≠Â≠¶ÁîüÁøªËØëÁöÑÂáÜÁ°ÆÂ∫¶„ÄÇ

ËØÑÂàÜÂü∫ÂáÜÁ§∫‰æãÔºö
- Â≠¶ÁîüÁ≠îÊ°à„ÄåÊûÅÁÇπ„ÄçÔºåÊ†áÂáÜÁ≠îÊ°à„ÄåÊùÜÔºõÊûÅÁÇπÔºõÁîµÊûÅ„Äç‚Üí 1.0 ÂàÜÔºàÊ†∏ÂøÉÂê´‰πâÂÆåÂÖ®ÂØπÂ∫îÔºâ
- Â≠¶ÁîüÁ≠îÊ°à„ÄåÁÉü„ÄçÔºåÊ†áÂáÜÁ≠îÊ°à„ÄåÁÉüÈõæ„Äç‚Üí 0.7 ÂàÜÔºà‰º†Ëææ‰∏ªË¶ÅÊ¶ÇÂøµÔºåÁªÜËäÇÁï•Áº∫Ôºâ
- Â≠¶ÁîüÁ≠îÊ°à„ÄåÂπ≥Âù¶ÁöÑ„ÄçÔºåÊ†áÂáÜÁ≠îÊ°à„ÄåÂπ≥Âéü„Äç‚Üí 0.5 ÂàÜÔºàÁõ∏ÂÖ≥‰ΩÜÂÅèÂêëÂΩ¢ÂÆπËØçÔºåÈúÄË¶ÅÊåáÂá∫ËØ≠‰πâÂ∑ÆÂºÇÔºâ

Âä°ÂøÖÂè™ËæìÂá∫ JSONÔºå‰∏çË¶ÅËß£Èáä„ÄÇJSON Ê†ºÂºèÂ¶Ç‰∏ãÔºö
{
  "Ëã±ÊñáËØçÊ±á": {
    "Ê†áÂáÜÁ≠îÊ°à": "Ê†áÂáÜ‰∏≠ÊñáÁøªËØë",
    "Áõ∏‰ººÂ∫¶": 0.000,
    "ËØ¥Êòé": "ÂèØÈÄâÔºåËã•Êó†ÂàôÁïôÁ©∫Â≠óÁ¨¶‰∏≤"
  }
}

ÂæÖËØÑ‰º∞ÁöÑËØçÊ±á‰∏éÂ≠¶ÁîüÁ≠îÊ°àÔºö
${termsList}`;
}

// Parse AI grading response
function parseGradingResponse(aiResponse, terms) {
  console.log(`[Parse Response] ÂºÄÂßãËß£ÊûêAIÂõûÂ§ç:`, aiResponse);
  console.log(`[Parse Response] ÈúÄË¶ÅËß£ÊûêÁöÑËØçÊ±á:`, terms);

  try {
    // Extract JSON from response
    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    console.log(`[Parse Response] JSONÂåπÈÖçÁªìÊûú:`, jsonMatch ? jsonMatch[0] : 'null');

    if (!jsonMatch) {
      console.warn(`[Parse Response] Êú™ÊâæÂà∞JSONÊ†ºÂºèÔºå‰ΩøÁî®fallbackËß£Êûê`);
      throw new Error('Êó†Ê≥ïËß£ÊûêAIÂõûÂ§çÊ†ºÂºè');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    console.log(`[Parse Response] JSONËß£ÊûêÊàêÂäü:`, parsed);

    const results = {};

    terms.forEach(term => {
      console.log(`[Parse Response] Â§ÑÁêÜËØçÊ±á: ${term}`);

      const termData = parsed[term] || parsed[term.trim()] || null;
      if (termData && typeof termData === 'object') {
        const similarityRaw = termData['Áõ∏‰ººÂ∫¶'] ?? termData['similarity'] ?? termData['score'];
        const similarity = clampSimilarity(typeof similarityRaw === 'string' ? parseFloat(similarityRaw) : similarityRaw);
        const standardAnswer = (termData['Ê†áÂáÜÁ≠îÊ°à'] ?? termData['Ê≠£Á°ÆÁ≠îÊ°à'] ?? '').toString().trim();
        const explanation = (termData['ËØ¥Êòé'] ?? termData['Ëß£Èáä'] ?? '').toString().trim();

        results[term] = {
          similarity: typeof similarity === 'number' ? similarity : null,
          standardAnswer: standardAnswer || null,
          explanation: explanation || null
        };

        console.log(`[Parse Response] ${term} Ëß£ÊûêÊàêÂäü - Áõ∏‰ººÂ∫¶:`, results[term].similarity, 'Ê†áÂáÜÁ≠îÊ°à:', results[term].standardAnswer, 'ËØ¥Êòé:', results[term].explanation);
      } else if (typeof termData === 'string') {
        // Backward compatibility (ÊóßÊ†ºÂºè)
        const isCorrect = termData === 'Ê≠£Á°Æ';
        results[term] = {
          similarity: isCorrect ? 1 : 0,
          standardAnswer: null,
          explanation: null
        };
        console.log(`[Parse Response] ${term} ‰ΩøÁî®ÊóßÊ†ºÂºèÂ≠óÁ¨¶‰∏≤ - Áõ∏‰ººÂ∫¶Ê®°Êãü:`, results[term].similarity);
      } else {
        console.log(`[Parse Response] ${term} Êú™Âú®Ëß£ÊûêÁªìÊûú‰∏≠ÊâæÂà∞Ôºå‰ΩøÁî®fallback`);
        results[term] = {
          similarity: null,
          standardAnswer: null,
          explanation: null
        };
      }
    });

    console.log(`[Parse Response] ÊúÄÁªàËß£ÊûêÁªìÊûú:`, results);
    return results;

  } catch (error) {
    console.error(`[Parse Response] JSONËß£ÊûêÂ§±Ë¥•:`, error);
    console.log(`[Parse Response] ‰ΩøÁî®fallbackËß£ÊûêÊñπÊ≥ï`);

    // Fallback parsing if JSON parsing fails
    const results = {};
    terms.forEach(term => {
      const termLower = term.toLowerCase();
      const responseLower = aiResponse.toLowerCase();
      results[term] = {
        similarity: responseLower.includes(termLower) ? 0.5 : null,
        standardAnswer: null,
        explanation: null
      };
      console.log(`[Parse Response] ${term} fallbackÁªìÊûú - Áõ∏‰ººÂ∫¶: ${results[term].similarity}`);
    });

    console.log(`[Parse Response] FallbackÊúÄÁªàÁªìÊûú:`, results);
    return results;
  }
}

// Display grading results
function displayGradingResults(results, totalCount) {
  LAST_GRADING_RESULTS = results || {};
  const scoreValues = Object.values(results)
    .map(r => (typeof r.similarity === 'number' ? r.similarity : null))
    .filter(v => v !== null);

  const avgSimilarity = scoreValues.length
    ? Math.round((scoreValues.reduce((sum, v) => sum + v, 0) / scoreValues.length) * 100) / 100
    : 0;

  const highMatches = scoreValues.filter(v => v >= SIMILARITY_THRESHOLD_STRICT).length;
  const mediumMatches = scoreValues.filter(v => v < SIMILARITY_THRESHOLD_STRICT && v >= SIMILARITY_THRESHOLD_PARTIAL).length;
  const strictLabel = SIMILARITY_THRESHOLD_STRICT.toFixed(2);
  const partialLabel = SIMILARITY_THRESHOLD_PARTIAL.toFixed(2);

  scoreSummaryEl.innerHTML = `
    <div>Âà§È¢òÂÆåÊàêÔºÅ</div>
    <div class="score-line">
      <span>Âπ≥ÂùáÁõ∏‰ººÂ∫¶Ôºö<strong>${avgSimilarity.toFixed(2)}</strong></span>
      <span>È´òÂåπÈÖç(‚â•${strictLabel}): <strong>${highMatches}</strong></span>
      <span>‰∏≠Á≠âÂåπÈÖç(‚â•${partialLabel}): <strong>${mediumMatches}</strong></span>
      <span>ÊÄªËØçÊï∞: <strong>${totalCount}</strong></span>
    </div>
  `;

  Object.entries(results).forEach(([term, result]) => {
    const itemEl = document.querySelector(`[data-term="${term}"]`)?.closest('.item');
    if (!itemEl) return;

    itemEl.classList.remove('correct', 'incorrect', 'partial');

    const similarity = typeof result.similarity === 'number' ? result.similarity : null;
    let bucket = 'incorrect';
    if (similarity !== null) {
      if (similarity >= SIMILARITY_THRESHOLD_STRICT) {
        bucket = 'correct';
      } else if (similarity >= SIMILARITY_THRESHOLD_PARTIAL) {
        bucket = 'partial';
      }
    }
    itemEl.classList.add(bucket);

    const termEl = itemEl.querySelector('.term');
    if (!termEl) return;

    let indicator = termEl.querySelector('.grade-indicator');
    if (!indicator) {
      indicator = document.createElement('span');
      indicator.className = 'grade-indicator';
      termEl.appendChild(indicator);
    }
    indicator.className = `grade-indicator ${bucket}`;
    indicator.textContent = similarity !== null ? similarity.toFixed(2) : '‚Äî';
    indicator.title = 'ËØ≠‰πâÁõ∏‰ººÂ∫¶ (0-1)';

    let detailsEl = itemEl.querySelector('.grading-details');
    if (!detailsEl) {
      detailsEl = document.createElement('div');
      detailsEl.className = 'grading-details';
      itemEl.appendChild(detailsEl);
    }

    detailsEl.innerHTML = '';

    if (similarity !== null) {
      const simRow = document.createElement('div');
      const simLabel = document.createElement('strong');
      simLabel.textContent = 'Áõ∏‰ººÂ∫¶:';
      simRow.appendChild(simLabel);
      simRow.appendChild(document.createTextNode(' ' + similarity.toFixed(2)));
      detailsEl.appendChild(simRow);
    }

    if (result.standardAnswer) {
      const answerRow = document.createElement('div');
      const answerLabel = document.createElement('strong');
      answerLabel.textContent = 'Ê†áÂáÜÁ≠îÊ°à:';
      answerRow.appendChild(answerLabel);
      answerRow.appendChild(document.createTextNode(' ' + result.standardAnswer));
      detailsEl.appendChild(answerRow);
    }

    if (result.explanation) {
      const explainRow = document.createElement('div');
      const explainLabel = document.createElement('strong');
      explainLabel.textContent = 'ËØ¥Êòé:';
      explainRow.appendChild(explainLabel);
      explainRow.appendChild(document.createTextNode(' ' + result.explanation));
      detailsEl.appendChild(explainRow);
    }

    if (!detailsEl.hasChildNodes()) {
      detailsEl.remove();
    }
  });

  aiResultsEl.style.display = 'block';
  aiConfigEl.style.display = 'none';

  toast(`Âà§È¢òÂÆåÊàêÔºÅÂπ≥ÂùáÁõ∏‰ººÂ∫¶ ${avgSimilarity.toFixed(2)}`, 'ok');
}

// Clear previous grading results
function clearGradingResults() {
  LAST_GRADING_RESULTS = {};
  document.querySelectorAll('.item').forEach(item => {
    item.classList.remove('correct', 'incorrect', 'partial');
    const indicator = item.querySelector('.grade-indicator');
    if (indicator) indicator.remove();
    const gradingDetails = item.querySelector('.grading-details');
    if (gradingDetails) gradingDetails.remove();
  });
}

// Check AI Identity for Display (returns result instead of updating UI)
async function checkAIIdentityForDisplay(apiUrl, apiKey, model = 'gpt-3.5-turbo') {
  console.log('[AI Identity] ÂºÄÂßãÊ£ÄÊµãAIË∫´‰ªΩ');
  console.log('[AI Identity] API URL:', apiUrl);
  console.log('[AI Identity] Ê®°Âûã:', model);
  console.log('[AI Identity] API Key ÈïøÂ∫¶:', apiKey ? apiKey.length : 0);

  const requestBody = {
    model: model,
    messages: [{
      role: 'user',
      content: '‰Ω†Â•ΩÔºåËØ∑ËØ¶ÁªÜ‰ªãÁªç‰∏Ä‰∏ã‰Ω†Ëá™Â∑±ÔºåÂåÖÊã¨‰Ω†ÁöÑÂêçÁß∞„ÄÅÁâàÊú¨„ÄÅ‰∏ªË¶ÅÂäüËÉΩÂíåÁâπËâ≤„ÄÇ'
    }],
    temperature: 0.1,
    max_tokens: 200
  };

  console.log('[AI Identity] ËØ∑Ê±Ç‰Ωì:', JSON.stringify(requestBody, null, 2));

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  console.log('[AI Identity] ÂìçÂ∫îÁä∂ÊÄÅ:', response.status, response.statusText);

  if (!response.ok) {
    const errorText = await response.text();
    console.error('[AI Identity] APIÈîôËØØÂìçÂ∫î:', errorText);
    throw new Error(`${response.status} ${response.statusText}: ${errorText}`);
  }

  const result = await response.json();
  console.log('[AI Identity] APIÂìçÂ∫î:', result);

  const message = result?.choices?.[0]?.message;
  if (!message) {
    console.error('[AI Identity] ÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏:', result);
    throw new Error('APIÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏');
  }

  const aiResponse = extractMessageText(message);
  if (!aiResponse) {
    console.error('[AI Identity] Êú™Ëé∑ÂæóÊñáÊú¨ÂõûÂ§ç:', message);
    throw new Error('AIÊú™ËøîÂõûÊñáÊú¨‰ø°ÊÅØ');
  }
  console.log('[AI Identity] AIÂõûÂ§ç:', aiResponse);

  return aiResponse;
}

// No auto-initialization needed for AI identity check

// --- Vocabulary source list (unique, in requested order) ---
// This will be dynamically populated based on uploaded article
let VOCABS = [];

const listEl = document.getElementById('list');
const filterEl = document.getElementById('filter');

// File upload elements
const fileInput = document.getElementById('article-file');
const uploadBtn = document.getElementById('upload-btn');
const uploadStatus = document.getElementById('upload-status');
const articleContent = document.getElementById('article-content');
const uploadSection = document.getElementById('upload-section');

// Build items
function makeId(term){
  return 'term-' + term.toLowerCase().replace(/[^a-z0-9]+/g,'-');
}

function jumpTo(term){
  // Try by dedicated anchor id first
  const byId = document.getElementById('t-' + term.toLowerCase().replace(/[^a-z0-9]+/g,'-'));
  if (byId) { byId.scrollIntoView({behavior:'smooth', block:'center'}); highlight(byId); return; }
  // Fallback: search first <strong> whose text includes the term case-insensitively
  const strongs = document.querySelectorAll('#article-content strong');
  const termLower = term.toLowerCase();
  for (const s of strongs){
    if (s.textContent.toLowerCase().includes(termLower)) { s.scrollIntoView({behavior:'smooth', block:'center'}); highlight(s); return; }
  }
  alert('Âú®ÊñáÁ´†‰∏≠Êú™ÊâæÂà∞ËØ•ËØçÔºö' + term);
}

function highlight(el){
  el.style.outline = '2px solid var(--accent-2)';
  el.style.boxShadow = '0 0 0 4px rgba(137,220,235,.25)';
  setTimeout(()=>{ el.style.outline = ''; el.style.boxShadow=''; }, 1500);
}

// File upload handling
function handleFileUpload(file) {
  if (!file) {
    uploadStatus.textContent = 'ËØ∑ÈÄâÊã©‰∏Ä‰∏™Êñá‰ª∂';
    return;
  }

  const reader = new FileReader();
  reader.onload = function(e) {
    const content = e.target.result;
    processArticleContent(content);
  };
  reader.onerror = function() {
    uploadStatus.textContent = 'Êñá‰ª∂ËØªÂèñÂ§±Ë¥•';
  };
  reader.readAsText(file, 'UTF-8');
}

// Process article content and extract vocabulary
function processArticleContent(content) {
  try {
    // Convert **markdown** to <strong> HTML tags and preserve paragraph structure
    const formattedContent = convertMarkdownToHtml(content);

    // Display the article content
    articleContent.innerHTML = formattedContent;

    // Extract vocabulary from ** marked words
    extractVocabulary(content);

    // Show article content and hide upload section
    uploadSection.style.display = 'none';
    articleContent.style.display = 'block';

    // Rebuild vocabulary list
    buildList();

    uploadStatus.textContent = 'ÊñáÁ´†‰∏ä‰º†ÊàêÂäüÔºÅ';
    uploadStatus.style.color = 'var(--ok)';
  } catch (error) {
    uploadStatus.textContent = 'Â§ÑÁêÜÊñáÁ´†ÂÜÖÂÆπÊó∂Âá∫Èîô: ' + error.message;
    uploadStatus.style.color = 'var(--warn)';
  }
}

// Convert markdown **word** to <strong>word</strong> and preserve paragraph structure
function convertMarkdownToHtml(content) {
  // Split content into paragraphs (separated by double newlines)
  const paragraphs = content.split('\n\n');

  // Process each paragraph
  const htmlParagraphs = paragraphs.map(paragraph => {
    // Convert **word** to <strong>word</strong>
    let htmlParagraph = paragraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    // Wrap in <p> tag
    return `<p>${htmlParagraph}</p>`;
  });

  return htmlParagraphs.join('\n');
}

// Extract vocabulary from ** marked words
function extractVocabulary(content) {
  // Find all words enclosed in **
  const regex = /\*\*(.*?)\*\*/g;
  const matches = content.match(regex);

  if (matches) {
    const vocabSet = new Set();
    matches.forEach(match => {
      // Remove ** and trim whitespace
      const word = match.replace(/\*\*/g, '').trim();
      if (word) {
        vocabSet.add(word);
      }
    });

    // Convert set to array and sort
    VOCABS = Array.from(vocabSet).sort();
  } else {
    VOCABS = [];
  }
}

// Function to find term by id fragment
function findTermByIdFragment(idFragment){
  for (const term of VOCABS) {
    const expectedId = term.toLowerCase().replace(/[^a-z0-9]+/g,'-');
    if (expectedId === idFragment) return term;
  }
  return null;
}

// Event listeners for file upload
uploadBtn.addEventListener('click', () => {
  handleFileUpload(fileInput.files[0]);
});

fileInput.addEventListener('change', () => {
  if (fileInput.files.length > 0) {
    uploadStatus.textContent = 'Â∑≤ÈÄâÊã©Êñá‰ª∂: ' + fileInput.files[0].name;
    uploadStatus.style.color = 'var(--text)';
  }
});

// Function to jump to and highlight input field
function jumpToInput(term){
  const inputEl = document.getElementById(makeId(term));
  if (inputEl) {
    inputEl.scrollIntoView({behavior:'smooth', block:'center'});
    inputEl.focus();
    // Highlight the input's parent item
    const itemEl = inputEl.closest('.item');
    if (itemEl) {
      itemEl.style.outline = '2px solid var(--accent-2)';
      itemEl.style.boxShadow = '0 0 0 4px rgba(137,220,235,.25)';
      setTimeout(()=>{
        itemEl.style.outline = '';
        itemEl.style.boxShadow='';
      }, 1500);
    }
  }
}

function buildList(){
  listEl.innerHTML = '';
  const q = filterEl.value?.trim().toLowerCase();
  for (const term of VOCABS){
    if (q && !term.toLowerCase().includes(q)) continue;
    const id = makeId(term);
    const div = document.createElement('div');
    div.className = 'item';
    div.innerHTML = `
      <div class="term" data-term="${term}">
        <span>${term}</span>
        <span class="jump" data-term="${term}">Ë∑≥Âà∞Êñá‰∏≠</span>
      </div>
      <input aria-label="${term} ‰∏≠ÊñáÊÑèÊÄù" placeholder="‰∏≠ÊñáÊÑèÊÄù‚Ä¶" id="${id}" data-term="${term}" />
    `;
    listEl.appendChild(div);
  }
}

// Initialize
buildList();

// Theme toggle functionality
const themeToggle = document.getElementById('theme-toggle');
const html = document.documentElement;

// Load saved theme or default to dark
const savedTheme = localStorage.getItem('theme') || 'dark';
if (savedTheme === 'light') {
  html.classList.add('light');
  themeToggle.textContent = '‚òÄÔ∏è ÊµÖËâ≤';
} else {
  themeToggle.textContent = 'üåô Ê∑±Ëâ≤';
}

themeToggle.addEventListener('click', () => {
  const isLight = html.classList.contains('light');
  if (isLight) {
    html.classList.remove('light');
    themeToggle.textContent = 'üåô Ê∑±Ëâ≤';
    localStorage.setItem('theme', 'dark');
  } else {
    html.classList.add('light');
    themeToggle.textContent = '‚òÄÔ∏è ÊµÖËâ≤';
    localStorage.setItem('theme', 'light');
  }
});

// Delegated jump - both term and jump button work
listEl.addEventListener('click', (e)=>{
  const t = e.target;
  if (t.classList.contains('jump')){
    jumpTo(t.dataset.term);
  } else if (t.classList.contains('term') || t.parentElement.classList.contains('term')){
    const term = t.dataset.term || t.parentElement.dataset.term;
    if (term) jumpTo(term);
  }
});

filterEl.addEventListener('input', buildList);

// Add focus event listener for input fields
listEl.addEventListener('focus', (e)=>{
  if (e.target.tagName === 'INPUT' && e.target.dataset.term) {
    jumpTo(e.target.dataset.term);
  }
}, true);

// Add click handler for article words to jump to corresponding input
document.getElementById('article-content').addEventListener('click', (e)=>{
  if (e.target.tagName === 'STRONG') {
    // Extract term from text content
    const term = e.target.textContent.trim();
    if (term && VOCABS.includes(term)) {
      jumpToInput(term);
    }
  }
});

// Persistence helpers
const KEY = 'geo_vocab_answers_v1';

function gather(){
  const data = {};
  for (const term of VOCABS){
    const el = document.getElementById(makeId(term));
    data[term] = el ? (el.value || '') : '';
  }
  return data;
}

function fill(data){
  if (!data) return;
  for (const term of VOCABS){
    const el = document.getElementById(makeId(term));
    if (el && term in data) el.value = data[term] || '';
  }
}

// Auto-load if present
try {
  const saved = JSON.parse(localStorage.getItem(KEY) || 'null');
  fill(saved);
} catch {}

// Button event listeners
document.getElementById('save').addEventListener('click', ()=>{
  const data = gather();
  localStorage.setItem(KEY, JSON.stringify(data));
  toast('Â∑≤‰øùÂ≠òÂà∞Êú¨Âú∞ ‚úì', 'ok');
});

document.getElementById('load').addEventListener('click', ()=>{
  try {
    const saved = JSON.parse(localStorage.getItem(KEY) || 'null');
    fill(saved);
    toast('Â∑≤‰ªéÊú¨Âú∞ÊÅ¢Â§ç ‚úì', 'ok');
  } catch {
    toast('Êú™ÊâæÂà∞Êú¨Âú∞Êï∞ÊçÆ', 'warn');
  }
});

document.getElementById('clear').addEventListener('click', ()=>{
  for (const term of VOCABS){
    const el = document.getElementById(makeId(term));
    if (el) el.value = '';
  }
  toast('Â∑≤Ê∏ÖÁ©∫ËæìÂÖ•', 'warn');
});

document.getElementById('export').addEventListener('click', ()=>{
  const data = gather();
  // Create CSV with header
  const rows = [["English","Chinese"]];
  for (const term of VOCABS){
    rows.push([term, (data[term] || '').replaceAll('\n',' ').trim()]);
  }
  const csv = toCSV(rows);
  // BOM for Excel UTF-8
  const blob = new Blob(['\uFEFF' + csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'english-chinese-fill.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  toast('CSV Â∑≤ÁîüÊàêÂπ∂ÂºÄÂßã‰∏ãËΩΩ', 'ok');
});

// Helper functions
function toCSV(rows){
  return rows.map(r => r.map(cell => csvCell(cell)).join(',')).join('\n');
}

function csvCell(v){
  if (v == null) return '';
  const s = String(v);
  if (/[",\n]/.test(s)) return '"' + s.replaceAll('"','""') + '"';
  return s;
}

// Toast notification
function toast(msg, kind){
  const t = document.createElement('div');
  t.textContent = msg;
  t.style.position='fixed';
  t.style.right='18px';
  t.style.bottom='18px';
  t.style.background = 'rgba(10,15,30,.95)';
  t.style.border='1px solid rgba(122,162,247,.3)';
  t.style.color = kind==='ok' ? 'var(--ok)' : (kind==='warn'? 'var(--warn)' : 'var(--text)');
  t.style.padding = '10px 12px';
  t.style.borderRadius='10px';
  t.style.boxShadow='0 6px 18px var(--shadow)';
  document.body.appendChild(t);
  setTimeout(()=>t.remove(), 2200);
}

// AI Grading System
let gradingInProgress = false;
const aiConfigEl = document.getElementById('ai-config');
const aiResultsEl = document.getElementById('ai-results');
const aiProgressEl = document.getElementById('ai-progress');
const progressFillEl = document.getElementById('progress-fill');
const progressTextEl = document.getElementById('progress-text');
const scoreSummaryEl = document.getElementById('score-summary');
const aiIdentityCheckBtn = document.getElementById('ai-identity-check');

// AI Grading Event Listeners
document.getElementById('ai-grade').addEventListener('click', async () => {
  if (aiConfigEl.style.display === 'none') {
    aiConfigEl.style.display = 'block';
    // Load saved API settings
    const savedApiUrl = localStorage.getItem('ai-api-url');
    const savedApiKey = localStorage.getItem('ai-api-key');
    const savedModel = localStorage.getItem('ai-model') || 'gpt-3.5-turbo';
    if (savedApiUrl) document.getElementById('api-url').value = savedApiUrl;
    if (savedApiKey) document.getElementById('api-key').value = savedApiKey;
    document.getElementById('ai-model').value = savedModel;
  } else {
    aiConfigEl.style.display = 'none';
  }
});

// AI Identity Check Button
aiIdentityCheckBtn.addEventListener('click', async () => {
  const savedApiUrl = localStorage.getItem('ai-api-url');
  const savedApiKey = localStorage.getItem('ai-api-key');
  const savedModel = localStorage.getItem('ai-model') || 'gpt-3.5-turbo';

  if (!savedApiUrl || !savedApiKey) {
    alert('ËØ∑ÂÖàÈÖçÁΩÆAPIÂú∞ÂùÄÂíåKeyÔºÅ\n\nÁÇπÂáª"ü§ñ AIÂà§È¢ò"ÊåâÈíÆËøõË°åÈÖçÁΩÆ„ÄÇ');
    return;
  }

  aiIdentityCheckBtn.textContent = 'üîç Ê£ÄÊµã‰∏≠...';
  aiIdentityCheckBtn.disabled = true;

  try {
    const identity = await checkAIIdentityForDisplay(savedApiUrl, savedApiKey, savedModel);
    // Show result in alert
    alert(`AIË∫´‰ªΩ‰ø°ÊÅØÔºö\n\n${identity}`);
  } catch (error) {
    alert(`AIË∫´‰ªΩÊ£ÄÊµãÂ§±Ë¥•Ôºö\n\n${error.message}`);
  } finally {
    aiIdentityCheckBtn.textContent = 'üîç Ê£ÄÊµãAIË∫´‰ªΩ';
    aiIdentityCheckBtn.disabled = false;
  }
});

document.getElementById('cancel-grade').addEventListener('click', () => {
  aiConfigEl.style.display = 'none';
  gradingInProgress = false;
});

document.getElementById('start-grade').addEventListener('click', async () => {
  const apiUrl = document.getElementById('api-url').value.trim();
  const apiKey = document.getElementById('api-key').value.trim();
  const model = document.getElementById('ai-model').value.trim() || 'gpt-3.5-turbo';

  if (!apiUrl || !apiKey) {
    toast('ËØ∑Â°´ÂÜôAPIÂú∞ÂùÄÂíåKey', 'warn');
    return;
  }

  // Save API settings
  localStorage.setItem('ai-api-url', apiUrl);
  localStorage.setItem('ai-api-key', apiKey);
  localStorage.setItem('ai-model', model);

  await startAIGrading(apiUrl, apiKey, model);
});

// Main AI grading function
async function startAIGrading(apiUrl, apiKey, model = 'gpt-3.5-turbo') {
  console.log('[Main Grading] ÂºÄÂßãAIÂà§È¢òÊµÅÁ®ã');
  console.log('[Main Grading] API URL:', apiUrl);
  console.log('[Main Grading] Ê®°Âûã:', model);
  console.log('[Main Grading] API Key ÈïøÂ∫¶:', apiKey ? apiKey.length : 0);

  if (gradingInProgress) {
    console.warn('[Main Grading] Âà§È¢òÂ∑≤Âú®ËøõË°å‰∏≠ÔºåË∑≥Ëøá');
    return;
  }

  gradingInProgress = true;
  aiProgressEl.style.display = 'block';
  aiResultsEl.style.display = 'none';

  // Clear previous results
  clearGradingResults();

  try {
    const data = gather();
    console.log('[Main Grading] Êî∂ÈõÜÁöÑÊï∞ÊçÆ:', data);

    const filledTerms = VOCABS.filter(term => data[term] && data[term].trim());
    console.log('[Main Grading] Â∑≤Â°´ÂÜôÁöÑËØçÊ±á:', filledTerms);
    console.log('[Main Grading] Â∑≤Â°´ÂÜôËØçÊ±áÊï∞Èáè:', filledTerms.length);

    if (filledTerms.length === 0) {
      console.warn('[Main Grading] Ê≤°ÊúâÂ°´ÂÜôÁöÑËØçÊ±á');
      toast('ËØ∑ÂÖàÂ°´ÂÜô‰∏Ä‰∫õÁ≠îÊ°à', 'warn');
      gradingInProgress = false;
      aiProgressEl.style.display = 'none';
      return;
    }

    progressTextEl.textContent = `ÂºÄÂßãÂà§È¢ò... (ÂÖ±${filledTerms.length}‰∏™ËØç)`;

    // Process in batches of 20
    const batchSize = 20;
    const batches = [];
    for (let i = 0; i < filledTerms.length; i += batchSize) {
      batches.push(filledTerms.slice(i, i + batchSize));
    }
    console.log('[Main Grading] ÂàÜÊâπÂ§ÑÁêÜ:', batches.length, '‰∏™ÊâπÊ¨°');

    let totalProcessed = 0;
    const results = {};

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      console.log(`[Main Grading] Â§ÑÁêÜÁ¨¨${i+1}Êâπ:`, batch);
      progressTextEl.textContent = `Ê≠£Âú®Â§ÑÁêÜÁ¨¨${i+1}/${batches.length}Êâπ (${batch.length}‰∏™ËØç)...`;

      try {
        const batchResults = await gradeBatch(batch, data, apiUrl, apiKey, model);
        console.log(`[Main Grading] Á¨¨${i+1}ÊâπÁªìÊûú:`, batchResults);
        Object.assign(results, batchResults);
        totalProcessed += batch.length;

        const progress = (totalProcessed / filledTerms.length) * 100;
        progressFillEl.style.width = progress + '%';
        console.log(`[Main Grading] ËøõÂ∫¶: ${progress}% (${totalProcessed}/${filledTerms.length})`);

        // Small delay between batches to avoid rate limiting
        if (i < batches.length - 1) {
          console.log(`[Main Grading] Á≠âÂæÖ1ÁßíÈÅøÂÖçÈ¢ëÁéáÈôêÂà∂`);
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      } catch (error) {
        console.error(`[Main Grading] Á¨¨${i+1}ÊâπÂ§ÑÁêÜÂ§±Ë¥•:`, error);
        toast(`Á¨¨${i+1}ÊâπÂ§ÑÁêÜÂ§±Ë¥•: ${error.message}`, 'warn');
      }
    }

    console.log('[Main Grading] ÊâÄÊúâÊâπÊ¨°Â§ÑÁêÜÂÆåÊàêÔºåÊúÄÁªàÁªìÊûú:', results);
    // Display results
    displayGradingResults(results, filledTerms.length);

  } catch (error) {
    console.error('[Main Grading] Âà§È¢òËøáÁ®ãÈîôËØØ:', error);
    toast('Âà§È¢òËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: ' + error.message, 'warn');
  } finally {
    gradingInProgress = false;
    aiProgressEl.style.display = 'none';
    console.log('[Main Grading] Âà§È¢òÊµÅÁ®ãÁªìÊùü');
  }
}

// Grade a batch of words
async function gradeBatch(terms, data, apiUrl, apiKey, model = 'gpt-3.5-turbo') {
  console.log(`[Batch Grading] ÂºÄÂßãÂ§ÑÁêÜÊâπÊ¨°:`, terms);
  console.log(`[Batch Grading] ‰ΩøÁî®Ê®°Âûã:`, model);

  const prompt = createGradingPrompt(terms, data);
  console.log(`[Batch Grading] ÁîüÊàêÁöÑÊèêÁ§∫ËØç:`, prompt);

  const requestBody = {
    model: model,
    messages: [{
      role: 'user',
      content: prompt
    }],
    temperature: 0.1
  };

  console.log(`[Batch Grading] ËØ∑Ê±Ç‰Ωì:`, JSON.stringify(requestBody, null, 2));

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  console.log(`[Batch Grading] ÂìçÂ∫îÁä∂ÊÄÅ:`, response.status, response.statusText);

  if (!response.ok) {
    const errorText = await response.text();
    console.error(`[Batch Grading] APIÈîôËØØÂìçÂ∫î:`, errorText);
    throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}: ${errorText}`);
  }

  const result = await response.json();
  console.log(`[Batch Grading] APIÂìçÂ∫î:`, result);

  if (!result.choices || !result.choices[0] || !result.choices[0].message) {
    console.error(`[Batch Grading] ÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏:`, result);
    throw new Error('APIÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏');
  }

  const aiResponse = result.choices[0].message.content;
  console.log(`[Batch Grading] AIÂõûÂ§çÂÜÖÂÆπ:`, aiResponse);

  const parsedResults = parseGradingResponse(aiResponse, terms);
  console.log(`[Batch Grading] Ëß£ÊûêÁªìÊûú:`, parsedResults);

  return parsedResults;
}

// Create grading prompt for AI
function createGradingPrompt(terms, data) {
  const termsList = terms.map(term => `${term}: ${data[term]}`).join('\n');

  return `ËØ∑Âà§Êñ≠‰ª•‰∏ãËã±ÊñáÂú∞Â≠¶ËØçÊ±áÁöÑ‰∏≠ÊñáÁøªËØëÊòØÂê¶Ê≠£Á°ÆÔºåÂπ∂Êèê‰æõÊ≠£Á°ÆÁ≠îÊ°à„ÄÇÂØπ‰∫éÊØè‰∏™ËØçÊ±áÔºåÂ¶ÇÊûúÁøªËØëÂü∫Êú¨Ê≠£Á°ÆÔºàÊÑèÊÄùÂØπÔºåÂÖÅËÆ∏ËΩªÂæÆÁöÑÁî®ËØçÂ∑ÆÂºÇÔºâÔºåËØ∑ÂõûÁ≠î"Ê≠£Á°Æ"ÔºõÂ¶ÇÊûúÁøªËØëÊòéÊòæÈîôËØØÊàñ‰∏çÁõ∏ÂÖ≥ÔºåËØ∑ÂõûÁ≠î"ÈîôËØØ"„ÄÇ

Êó†ËÆ∫Ê≠£Á°Æ‰∏éÂê¶ÔºåÈÉΩËØ∑Êèê‰æõÊ†áÂáÜÁöÑ‰∏≠ÊñáÁøªËØë„ÄÇ

ËØçÊ±áÂàóË°®Ôºö
${termsList}

ËØ∑‰∏•Ê†ºÊåâÁÖß‰ª•‰∏ãJSONÊ†ºÂºèÂõûÁ≠îÔºå‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïÂÖ∂‰ªñÂÜÖÂÆπÔºö
{
  "ËØçÊ±á1": {
    "Âà§Êñ≠": "Ê≠£Á°Æ",
    "Ê≠£Á°ÆÁ≠îÊ°à": "Ê†áÂáÜ‰∏≠ÊñáÁøªËØë"
  },
  "ËØçÊ±á2": {
    "Âà§Êñ≠": "ÈîôËØØ",
    "Ê≠£Á°ÆÁ≠îÊ°à": "Ê†áÂáÜ‰∏≠ÊñáÁøªËØë"
  },
  ...
}`;
}

// Parse AI grading response
function parseGradingResponse(aiResponse, terms) {
  console.log(`[Parse Response] ÂºÄÂßãËß£ÊûêAIÂõûÂ§ç:`, aiResponse);
  console.log(`[Parse Response] ÈúÄË¶ÅËß£ÊûêÁöÑËØçÊ±á:`, terms);

  try {
    // Extract JSON from response
    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    console.log(`[Parse Response] JSONÂåπÈÖçÁªìÊûú:`, jsonMatch ? jsonMatch[0] : 'null');

    if (!jsonMatch) {
      console.warn(`[Parse Response] Êú™ÊâæÂà∞JSONÊ†ºÂºèÔºå‰ΩøÁî®fallbackËß£Êûê`);
      throw new Error('Êó†Ê≥ïËß£ÊûêAIÂõûÂ§çÊ†ºÂºè');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    console.log(`[Parse Response] JSONËß£ÊûêÊàêÂäü:`, parsed);

    const results = {};

    terms.forEach(term => {
      console.log(`[Parse Response] Â§ÑÁêÜËØçÊ±á: ${term}`);

      if (parsed[term]) {
        const termData = parsed[term];
        console.log(`[Parse Response] ${term} ÁöÑÊï∞ÊçÆ:`, termData);

        if (typeof termData === 'object') {
          // New format with correct answer
          const isCorrect = termData['Âà§Êñ≠'] === 'Ê≠£Á°Æ';
          const correctAnswer = termData['Ê≠£Á°ÆÁ≠îÊ°à'];
          results[term] = {
            isCorrect: isCorrect,
            correctAnswer: correctAnswer
          };
          console.log(`[Parse Response] ${term} Êñ∞Ê†ºÂºèËß£Êûê - Ê≠£Á°ÆÊÄß: ${isCorrect}, Á≠îÊ°à: ${correctAnswer}`);
        } else {
          // Old format - just boolean
          const isCorrect = termData === 'Ê≠£Á°Æ';
          results[term] = {
            isCorrect: isCorrect,
            correctAnswer: null
          };
          console.log(`[Parse Response] ${term} ÊóßÊ†ºÂºèËß£Êûê - Ê≠£Á°ÆÊÄß: ${isCorrect}`);
        }
      } else {
        console.log(`[Parse Response] ${term} Êú™Âú®Ëß£ÊûêÁªìÊûú‰∏≠ÊâæÂà∞Ôºå‰ΩøÁî®fallback`);
        // Fallback: check if the response contains the term and result
        const termResult = aiResponse.toLowerCase().includes(term.toLowerCase()) &&
                          aiResponse.toLowerCase().includes('Ê≠£Á°Æ');
        results[term] = {
          isCorrect: termResult,
          correctAnswer: null
        };
        console.log(`[Parse Response] ${term} fallbackËß£Êûê - Ê≠£Á°ÆÊÄß: ${termResult}`);
      }
    });

    console.log(`[Parse Response] ÊúÄÁªàËß£ÊûêÁªìÊûú:`, results);
    return results;

  } catch (error) {
    console.error(`[Parse Response] JSONËß£ÊûêÂ§±Ë¥•:`, error);
    console.log(`[Parse Response] ‰ΩøÁî®fallbackËß£ÊûêÊñπÊ≥ï`);

    // Fallback parsing if JSON parsing fails
    const results = {};
    terms.forEach(term => {
      const termLower = term.toLowerCase();
      const responseLower = aiResponse.toLowerCase();
      const isCorrect = responseLower.includes(termLower) && responseLower.includes('Ê≠£Á°Æ');
      results[term] = {
        isCorrect: isCorrect,
        correctAnswer: null
      };
      console.log(`[Parse Response] ${term} fallbackÁªìÊûú - Ê≠£Á°ÆÊÄß: ${isCorrect}`);
    });

    console.log(`[Parse Response] FallbackÊúÄÁªàÁªìÊûú:`, results);
    return results;
  }
}

// Display grading results
function displayGradingResults(results, totalCount) {
  const correctCount = Object.values(results).filter(r => r.isCorrect).length;

  // Update score summary
  scoreSummaryEl.innerHTML = `
    <div>Âà§È¢òÂÆåÊàêÔºÅ</div>
    <div style="margin-top: 8px; font-size: 20px;">
      Ê≠£Á°Æ: <span style="color: var(--ok)">${correctCount}</span> /
      ÊÄªÊï∞: <span style="color: var(--text)">${totalCount}</span>
      <span style="color: var(--accent); margin-left: 12px;">
        (${Math.round(correctCount / totalCount * 100)}%)
      </span>
    </div>
  `;

  // Update individual items
  Object.entries(results).forEach(([term, result]) => {
    const itemEl = document.querySelector(`[data-term="${term}"]`)?.closest('.item');
    if (itemEl) {
      itemEl.classList.remove('correct', 'incorrect');
      itemEl.classList.add(result.isCorrect ? 'correct' : 'incorrect');

      // Add grade indicator
      const termEl = itemEl.querySelector('.term');
      let indicator = termEl.querySelector('.grade-indicator');
      if (!indicator) {
        indicator = document.createElement('span');
        indicator.className = 'grade-indicator';
        termEl.appendChild(indicator);
      }
      indicator.className = `grade-indicator ${result.isCorrect ? 'correct' : 'incorrect'}`;
      indicator.textContent = result.isCorrect ? '‚úì' : '‚úó';

      // Add correct answer if available
      let correctAnswerEl = itemEl.querySelector('.correct-answer');
      if (result.correctAnswer) {
        if (!correctAnswerEl) {
          correctAnswerEl = document.createElement('div');
          correctAnswerEl.className = 'correct-answer';
          itemEl.appendChild(correctAnswerEl);
        }
        correctAnswerEl.innerHTML = `<strong>Ê≠£Á°ÆÁ≠îÊ°à:</strong> ${result.correctAnswer}`;
      } else if (correctAnswerEl) {
        correctAnswerEl.remove();
      }
    }
  });

  aiResultsEl.style.display = 'block';
  aiConfigEl.style.display = 'none';

  toast(`Âà§È¢òÂÆåÊàêÔºÅÊ≠£Á°ÆÁéá: ${Math.round(correctCount / totalCount * 100)}%`, 'ok');
}

// Clear previous grading results
function clearGradingResults() {
  document.querySelectorAll('.item').forEach(item => {
    item.classList.remove('correct', 'incorrect');
    const indicator = item.querySelector('.grade-indicator');
    if (indicator) indicator.remove();
    const correctAnswer = item.querySelector('.correct-answer');
    if (correctAnswer) correctAnswer.remove();
  });
}

// Check AI Identity for Display (returns result instead of updating UI)
async function checkAIIdentityForDisplay(apiUrl, apiKey, model = 'gpt-3.5-turbo') {
  console.log('[AI Identity] ÂºÄÂßãÊ£ÄÊµãAIË∫´‰ªΩ');
  console.log('[AI Identity] API URL:', apiUrl);
  console.log('[AI Identity] Ê®°Âûã:', model);
  console.log('[AI Identity] API Key ÈïøÂ∫¶:', apiKey ? apiKey.length : 0);

  const requestBody = {
    model: model,
    messages: [{
      role: 'user',
      content: '‰Ω†Â•ΩÔºåËØ∑ËØ¶ÁªÜ‰ªãÁªç‰∏Ä‰∏ã‰Ω†Ëá™Â∑±ÔºåÂåÖÊã¨‰Ω†ÁöÑÂêçÁß∞„ÄÅÁâàÊú¨„ÄÅ‰∏ªË¶ÅÂäüËÉΩÂíåÁâπËâ≤„ÄÇ'
    }],
    temperature: 0.1,
    max_tokens: 200
  };

  console.log('[AI Identity] ËØ∑Ê±Ç‰Ωì:', JSON.stringify(requestBody, null, 2));

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  console.log('[AI Identity] ÂìçÂ∫îÁä∂ÊÄÅ:', response.status, response.statusText);

  if (!response.ok) {
    const errorText = await response.text();
    console.error('[AI Identity] APIÈîôËØØÂìçÂ∫î:', errorText);
    throw new Error(`${response.status} ${response.statusText}: ${errorText}`);
  }

  const result = await response.json();
  console.log('[AI Identity] APIÂìçÂ∫î:', result);

  if (!result.choices || !result.choices[0] || !result.choices[0].message) {
    console.error('[AI Identity] ÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏:', result);
    throw new Error('APIÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏');
  }

  const aiResponse = result.choices[0].message.content.trim();
  console.log('[AI Identity] AIÂõûÂ§ç:', aiResponse);

  return aiResponse;
}

// No auto-initialization needed for AI identity check